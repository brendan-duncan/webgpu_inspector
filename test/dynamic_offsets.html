<!DOCTYPE html>
<html>
<head>
    <title>WebGPU Dynamic Offsets</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #333; }
        canvas { background-color: #000; }
    </style>
</head>
<body>
    <canvas id="webgpu-canvas" width="600" height="400"></canvas>
    <script type="module">
const SHADER_CODE = `
    struct Uniforms {
        color: vec4f,
        padding: vec3f,
    };

    @group(0) @binding(0) var<uniform> uniforms: Uniforms;

    @vertex
    fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4f {
        var pos = array<vec2f, 3>(
            vec2f( 0.0,  0.5), // Top
            vec2f(-0.5, -0.5), // Bottom Left
            vec2f( 0.5, -0.5)  // Bottom Right
        );

        var offset = select(vec2f(-0.5, 0.0), vec2f(0.5, 0.0), uniforms.color.r == 1.0);
        return vec4f(pos[vertexIndex] + offset, 0.0, 1.0);
    }

    @fragment
    fn fs_main() -> @location(0) vec4f {
        return uniforms.color;
    }
`;

async function initWebGPU() {
    if (!navigator.gpu) {
        alert("WebGPU not supported on this browser.");
        return;
    }

    const canvas = document.getElementById('webgpu-canvas');
    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    const context = canvas.getContext('webgpu');

    const minUniformBufferOffsetAlignment = device.limits.minUniformBufferOffsetAlignment;
    console.log(`Min Uniform Buffer Offset Alignment: ${minUniformBufferOffsetAlignment}`);

    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
    context.configure({
        device: device,
        format: presentationFormat,
        alphaMode: 'opaque'
    });

    const shaderModule = device.createShaderModule({
        code: SHADER_CODE,
    });

    const UNIFORM_SIZE_BYTES = 32;

    // Calculate the total stride (aligned size) needed for one set of uniform data.
    // This is the offset step between uniform blocks in the buffer.
    const uniformStride = Math.ceil(UNIFORM_SIZE_BYTES / minUniformBufferOffsetAlignment) * minUniformBufferOffsetAlignment;
    console.log(`Uniform Stride (Aligned Offset): ${uniformStride} bytes`);
    
    const NUM_OBJECTS = 2; // We want two different uniform data sets (for two triangles)
    const totalBufferSize = uniformStride * NUM_OBJECTS;

    const uniformBuffer = device.createBuffer({
        size: totalBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        label: 'Dynamic Uniform Buffer'
    });
    console.log(`Created uniform buffer of size: ${totalBufferSize} bytes`);

    const color1 = new Float32Array([1.0, 0.0, 0.0, 1.0]);
    const color2 = new Float32Array([0.0, 1.0, 0.0, 1.0]);

    device.queue.writeBuffer(uniformBuffer, 0, color1);
    device.queue.writeBuffer(uniformBuffer, uniformStride, color2);

    const bindGroupLayout = device.createBindGroupLayout({
        label: 'Dynamic Bind Group Layout',
        entries: [{
            binding: 0,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: 'uniform', hasDynamicOffset: true },
        }],
    });

    const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout],
    });

    const bindGroup = device.createBindGroup({
        label: 'Dynamic Bind Group',
        layout: bindGroupLayout,
        entries: [{ binding: 0, resource: { buffer: uniformBuffer, size: UNIFORM_SIZE_BYTES }, }],
    });

    const pipeline = device.createRenderPipeline({
        layout: pipelineLayout,
        vertex: {
            module: shaderModule,
            entryPoint: 'vs_main',
        },
        fragment: {
            module: shaderModule,
            entryPoint: 'fs_main',
            targets: [{
                format: presentationFormat,
            }],
        },
        primitive: {
            topology: 'triangle-list',
        },
    });

    function frame() {
        const commandEncoder = device.createCommandEncoder();
        const textureView = context.getCurrentTexture().createView();

        const renderPassEncoder = commandEncoder.beginRenderPass({
            colorAttachments: [{
                view: textureView,
                clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 },
                loadOp: 'clear',
                storeOp: 'store',
            }],
        });

        renderPassEncoder.setPipeline(pipeline);

        const offset1 = 0;
        renderPassEncoder.setBindGroup(0, bindGroup, [offset1]);
        renderPassEncoder.draw(3);

        const offset2 = uniformStride;
        renderPassEncoder.setBindGroup(0, bindGroup, [offset2]);
        renderPassEncoder.draw(3);

        renderPassEncoder.end();

        device.queue.submit([commandEncoder.finish()]);

        requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
}

initWebGPU();
    </script>
</body>
</html>
