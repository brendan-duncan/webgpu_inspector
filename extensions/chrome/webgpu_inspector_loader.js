!function(){function e(){!function(e){async function t(e,t='application/octet-stream'){return await new Promise(((r,s)=>{const n=Object.assign(new FileReader,{onload:()=>r(n.result),onerror:()=>s(n.error)});n.readAsDataURL(new File([e],'',{type:t}))}))}class r{constructor(e){this._lastSlotId=0,this.slots=new Map,e&&(this.name=e)}static get enabled(){return 0==r._disableSignals}static get disabled(){return r._disableSignals>0}static disable(){return r._disableSignals++}static enable(e){return e?(r._disableSignals=0,0):r._disableSignals>0?r._disableSignals--:0}static disconnect(e,t,s){for(const n in e){const o=e[n];o.constructor===r&&o.disconnect(t,s)}}static getSignals(e,t){t=t||[];for(const s in e){const n=e[s];n.constructor===r&&t.push(n)}return t}get hasListeners(){return this.slots.size>0}emit(){if(!r.disabled)for(const e of this.slots){const t=e[1][0],s=e[1][1]||t;if(t)if(t.constructor===r)t.emit.apply(s,arguments);else{let e=t.apply(s,arguments);if(e)return e}}}addListener(e,t){return this.isListening(e,t)?null:(this.slots.set(this._lastSlotId++,[e,t]),this._lastSlotId-1)}isListening(e,t){for(const r of this.slots){const s=r[1];if(e&&!t){if(s[0]===e||s[1]===e)return!0}else if(!e&&t){if(s[1]===t)return!0}else if(s[0]===e&&s[1]===t)return!0}return!1}disconnect(e,t){if(null==e&&null==t)return this.slots.clear(),!0;if(e.constructor===Number){const t=e;return!!this.slots.has(t)&&(this.slots.delete(t),!0)}let r=!1;for(const s of this.slots){const n=s[0],o=s[1];e&&!t?o[0]!==e&&o[1]!==e||(this.slots.delete(n),r=!0):!e&&t?o[1]===t&&(this.slots.delete(n),r=!0):o[0]===e&&o[1]===t&&(this.slots.delete(n),r=!0)}return r}}function s(){if(!Error.captureStackTrace)return'';const e={};return Error.captureStackTrace(e,s),e.stack?e.stack.split('\n').map((e=>e.split('at ')[1])).slice(2).filter((e=>e&&!e.includes('webgpu_inspector_loader.js'))).join('\n'):''}r._disableSignals=0;const n=new Set([GPUAdapter,GPUDevice,GPUBuffer,GPUTexture,GPUTextureView,GPUSampler,GPUBindGroupLayout,GPUBindGroup,GPUPipelineLayout,GPUShaderModule,GPUComputePipeline,GPURenderPipeline,GPUCommandBuffer,GPUCommandEncoder,GPUComputePassEncoder,GPURenderPassEncoder,GPURenderBundle,GPURenderBundleEncoder,GPUQueue,GPUQuerySet,GPUCanvasContext]),o=new Set(['createBuffer','createTexture','createSampler','importExternalTexture','createBindGroupLayout','createPipelineLayout','createBindGroup','createShaderModule','createComputePipeline','createRenderPipeline','createComputePipelineAsync','createRenderPipelineAsync','createCommandEncoder','createRenderBundleEncoder','createQuerySet','createView']);class i{constructor(e){this._idGenerator=e,this.onPreCall=new r,this.onPostCall=new r,this.onPromise=new r,this.onPromiseResolve=new r,this.recordStacktraces=!1,this._skipRecord=0,this._wrapGPUTypes()}_wrapGPUTypes(){GPU.prototype.requestAdapter=this._wrapMethod('requestAdapter',GPU.prototype.requestAdapter),GPU.prototype.getPreferredFormat=this._wrapMethod('getPreferredFormat',GPU.prototype.getPreferredFormat),GPUAdapter.prototype.requestDevice=this._wrapMethod('requestDevice',GPUAdapter.prototype.requestDevice),GPUDevice.prototype.destroy=this._wrapMethod('destroy',GPUDevice.prototype.destroy),GPUDevice.prototype.createBuffer=this._wrapMethod('createBuffer',GPUDevice.prototype.createBuffer),GPUDevice.prototype.createTexture=this._wrapMethod('createTexture',GPUDevice.prototype.createTexture),GPUDevice.prototype.createSampler=this._wrapMethod('createSampler',GPUDevice.prototype.createSampler),GPUDevice.prototype.importExternalTexture=this._wrapMethod('importExternalTexture',GPUDevice.prototype.importExternalTexture),GPUDevice.prototype.createBindGroupLayout=this._wrapMethod('createBindGroupLayout',GPUDevice.prototype.createBindGroupLayout),GPUDevice.prototype.createPipelineLayout=this._wrapMethod('createPipelineLayout',GPUDevice.prototype.createPipelineLayout),GPUDevice.prototype.createBindGroup=this._wrapMethod('createBindGroup',GPUDevice.prototype.createBindGroup),GPUDevice.prototype.createShaderModule=this._wrapMethod('createShaderModule',GPUDevice.prototype.createShaderModule),GPUDevice.prototype.createComputePipeline=this._wrapMethod('createComputePipeline',GPUDevice.prototype.createComputePipeline),GPUDevice.prototype.createRenderPipeline=this._wrapMethod('createRenderPipeline',GPUDevice.prototype.createRenderPipeline),GPUDevice.prototype.createComputePipelineAsync=this._wrapMethod('createComputePipelineAsync',GPUDevice.prototype.createComputePipelineAsync),GPUDevice.prototype.createRenderPipelineAsync=this._wrapMethod('createRenderPipelineAsync',GPUDevice.prototype.createRenderPipelineAsync),GPUDevice.prototype.createCommandEncoder=this._wrapMethod('createCommandEncoder',GPUDevice.prototype.createCommandEncoder),GPUDevice.prototype.createRenderBundleEncoder=this._wrapMethod('createRenderBundleEncoder',GPUDevice.prototype.createRenderBundleEncoder),GPUDevice.prototype.createQuerySet=this._wrapMethod('createQuerySet',GPUDevice.prototype.createQuerySet),GPUBuffer.prototype.mapAsync=this._wrapMethod('mapAsync',GPUBuffer.prototype.mapAsync),GPUBuffer.prototype.getMappedRange=this._wrapMethod('getMappedRange',GPUBuffer.prototype.getMappedRange),GPUBuffer.prototype.unmap=this._wrapMethod('unmap',GPUBuffer.prototype.unmap),GPUBuffer.prototype.destroy=this._wrapMethod('destroy',GPUBuffer.prototype.destroy),GPUTexture.prototype.createView=this._wrapMethod('createView',GPUTexture.prototype.createView),GPUTexture.prototype.destroy=this._wrapMethod('destroy',GPUTexture.prototype.destroy),GPUShaderModule.prototype.getCompilationInfo=this._wrapMethod('getCompilationInfo',GPUShaderModule.prototype.getCompilationInfo),GPUComputePipeline.prototype.getBindGroupLayout=this._wrapMethod('getBindGroupLayout',GPUComputePipeline.prototype.getBindGroupLayout),GPURenderPipeline.prototype.getBindGroupLayout=this._wrapMethod('getBindGroupLayout',GPURenderPipeline.prototype.getBindGroupLayout),GPUCommandEncoder.prototype.beginRenderPass=this._wrapMethod('beginRenderPass',GPUCommandEncoder.prototype.beginRenderPass),GPUCommandEncoder.prototype.beginComputePass=this._wrapMethod('beginComputePass',GPUCommandEncoder.prototype.beginComputePass),GPUCommandEncoder.prototype.copyBufferToBuffer=this._wrapMethod('copyBufferToBuffer',GPUCommandEncoder.prototype.copyBufferToBuffer),GPUCommandEncoder.prototype.copyBufferToTexture=this._wrapMethod('copyBufferToTexture',GPUCommandEncoder.prototype.copyBufferToTexture),GPUCommandEncoder.prototype.copyTextureToBuffer=this._wrapMethod('copyTextureToBuffer',GPUCommandEncoder.prototype.copyTextureToBuffer),GPUCommandEncoder.prototype.copyTextureToTexture=this._wrapMethod('copyTextureToTexture',GPUCommandEncoder.prototype.copyTextureToTexture),GPUCommandEncoder.prototype.clearBuffer=this._wrapMethod('clearBuffer',GPUCommandEncoder.prototype.clearBuffer),GPUCommandEncoder.prototype.resolveQuerySet=this._wrapMethod('resolveQuerySet',GPUCommandEncoder.prototype.resolveQuerySet),GPUCommandEncoder.prototype.finish=this._wrapMethod('finish',GPUCommandEncoder.prototype.finish),GPUCommandEncoder.prototype.pushDebugGroup=this._wrapMethod('pushDebugGroup',GPUCommandEncoder.prototype.pushDebugGroup),GPUCommandEncoder.prototype.popDebugGroup=this._wrapMethod('popDebugGroup',GPUCommandEncoder.prototype.popDebugGroup),GPUCommandEncoder.prototype.insertDebugMarker=this._wrapMethod('insertDebugMarker',GPUCommandEncoder.prototype.insertDebugMarker),GPUComputePassEncoder.prototype.setPipeline=this._wrapMethod('setPipeline',GPUComputePassEncoder.prototype.setPipeline),GPUComputePassEncoder.prototype.dispatchWorkgroups=this._wrapMethod('dispatchWorkgroups',GPUComputePassEncoder.prototype.dispatchWorkgroups),GPUComputePassEncoder.prototype.dispatchWorkgroupsIndirect=this._wrapMethod('dispatchWorkgroupsIndirect',GPUComputePassEncoder.prototype.dispatchWorkgroupsIndirect),GPUComputePassEncoder.prototype.end=this._wrapMethod('end',GPUComputePassEncoder.prototype.end),GPUComputePassEncoder.prototype.setBindGroup=this._wrapMethod('setBindGroup',GPUComputePassEncoder.prototype.setBindGroup),GPUComputePassEncoder.prototype.pushDebugGroup=this._wrapMethod('pushDebugGroup',GPUComputePassEncoder.prototype.pushDebugGroup),GPUComputePassEncoder.prototype.popDebugGroup=this._wrapMethod('popDebugGroup',GPUComputePassEncoder.prototype.popDebugGroup),GPUComputePassEncoder.prototype.insertDebugMarker=this._wrapMethod('insertDebugMarker',GPUComputePassEncoder.prototype.insertDebugMarker),GPURenderPassEncoder.prototype.setViewport=this._wrapMethod('setViewport',GPURenderPassEncoder.prototype.setViewport),GPURenderPassEncoder.prototype.setScissorRect=this._wrapMethod('setScissorRect',GPURenderPassEncoder.prototype.setScissorRect),GPURenderPassEncoder.prototype.setBlendConstant=this._wrapMethod('setBlendConstant',GPURenderPassEncoder.prototype.setBlendConstant),GPURenderPassEncoder.prototype.setStencilReference=this._wrapMethod('setStencilReference',GPURenderPassEncoder.prototype.setStencilReference),GPURenderPassEncoder.prototype.beginOcclusionQuery=this._wrapMethod('beginOcclusionQuery',GPURenderPassEncoder.prototype.beginOcclusionQuery),GPURenderPassEncoder.prototype.endOcclusionQuery=this._wrapMethod('endOcclusionQuery',GPURenderPassEncoder.prototype.endOcclusionQuery),GPURenderPassEncoder.prototype.executeBundles=this._wrapMethod('executeBundles',GPURenderPassEncoder.prototype.executeBundles),GPURenderPassEncoder.prototype.end=this._wrapMethod('end',GPURenderPassEncoder.prototype.end),GPURenderPassEncoder.prototype.setPipeline=this._wrapMethod('setPipeline',GPURenderPassEncoder.prototype.setPipeline),GPURenderPassEncoder.prototype.setIndexBuffer=this._wrapMethod('setIndexBuffer',GPURenderPassEncoder.prototype.setIndexBuffer),GPURenderPassEncoder.prototype.setVertexBuffer=this._wrapMethod('setVertexBuffer',GPURenderPassEncoder.prototype.setVertexBuffer),GPURenderPassEncoder.prototype.draw=this._wrapMethod('draw',GPURenderPassEncoder.prototype.draw),GPURenderPassEncoder.prototype.drawIndexed=this._wrapMethod('drawIndexed',GPURenderPassEncoder.prototype.drawIndexed),GPURenderPassEncoder.prototype.drawIndirect=this._wrapMethod('drawIndirect',GPURenderPassEncoder.prototype.drawIndirect),GPURenderPassEncoder.prototype.drawIndexedIndirect=this._wrapMethod('drawIndexedIndirect',GPURenderPassEncoder.prototype.drawIndexedIndirect),GPURenderPassEncoder.prototype.setBindGroup=this._wrapMethod('setBindGroup',GPURenderPassEncoder.prototype.setBindGroup),GPURenderPassEncoder.prototype.pushDebugGroup=this._wrapMethod('pushDebugGroup',GPURenderPassEncoder.prototype.pushDebugGroup),GPURenderPassEncoder.prototype.popDebugGroup=this._wrapMethod('popDebugGroup',GPURenderPassEncoder.prototype.popDebugGroup),GPURenderPassEncoder.prototype.insertDebugMarker=this._wrapMethod('insertDebugMarker',GPURenderPassEncoder.prototype.insertDebugMarker),GPUQueue.prototype.submit=this._wrapMethod('submit',GPUQueue.prototype.submit),GPUQueue.prototype.writeBuffer=this._wrapMethod('writeBuffer',GPUQueue.prototype.writeBuffer),GPUQueue.prototype.writeTexture=this._wrapMethod('writeTexture',GPUQueue.prototype.writeTexture),GPUQueue.prototype.copyExternalImageToTexture=this._wrapMethod('copyExternalImageToTexture',GPUQueue.prototype.copyExternalImageToTexture),GPUQuerySet.prototype.destroy=this._wrapMethod('destroy',GPUQuerySet.prototype.destroy),GPUCanvasContext.prototype.configure=this._wrapMethod('configure',GPUCanvasContext.prototype.configure),GPUCanvasContext.prototype.unconfigure=this._wrapMethod('unconfigure',GPUCanvasContext.prototype.unconfigure),GPUCanvasContext.prototype.getCurrentTexture=this._wrapMethod('getCurrentTexture',GPUCanvasContext.prototype.getCurrentTexture),GPURenderBundleEncoder.prototype.draw=this._wrapMethod('draw',GPURenderBundleEncoder.prototype.draw),GPURenderBundleEncoder.prototype.drawIndexed=this._wrapMethod('drawIndexed',GPURenderBundleEncoder.prototype.drawIndexed),GPURenderBundleEncoder.prototype.drawIndirect=this._wrapMethod('drawIndirect',GPURenderBundleEncoder.prototype.drawIndirect),GPURenderBundleEncoder.prototype.drawIndexedIndirect=this._wrapMethod('drawIndexedIndirect',GPURenderBundleEncoder.prototype.drawIndexedIndirect),GPURenderBundleEncoder.prototype.finish=this._wrapMethod('finish',GPURenderBundleEncoder.prototype.finish),GPURenderBundleEncoder.prototype.insertDebugMarker=this._wrapMethod('insertDebugMarker',GPURenderBundleEncoder.prototype.insertDebugMarker),GPURenderBundleEncoder.prototype.popDebugGroup=this._wrapMethod('popDebugGroup',GPURenderBundleEncoder.prototype.popDebugGroup),GPURenderBundleEncoder.prototype.pushDebugGroup=this._wrapMethod('pushDebugGroup',GPURenderBundleEncoder.prototype.pushDebugGroup),GPURenderBundleEncoder.prototype.setBindGroup=this._wrapMethod('setBindGroup',GPURenderBundleEncoder.prototype.setBindGroup),GPURenderBundleEncoder.prototype.setIndexBuffer=this._wrapMethod('setIndexBuffer',GPURenderBundleEncoder.prototype.setIndexBuffer),GPURenderBundleEncoder.prototype.setPipeline=this._wrapMethod('setPipeline',GPURenderBundleEncoder.prototype.setPipeline),GPURenderBundleEncoder.prototype.setVertexBuffer=this._wrapMethod('setVertexBuffer',GPURenderBundleEncoder.prototype.setVertexBuffer)}disableRecording(){this._skipRecord++}enableRecording(){this._skipRecord--,this._skipRecord<0&&(this._skipRecord=0)}get isRecordingEnabled(){return 0===this._skipRecord}_wrapMethod(e,t){const r=this;return function(){const n=this,i=[...arguments];if(r._skipRecord>0)return t.call(n,...i);if(r.onPreCall.emit(n,e,i))return;const a=t.call(n,...i),c=o.has(e)||r instanceof GPURenderBundleEncoder&&'finish'===e,d=r.recordStacktraces||c?s():void 0;if(a instanceof Promise){const t=r._idGenerator.getNextId(n);r.onPromise.emit(n,e,i,t,d);const s=a;return new Promise((o=>{s.then((s=>{r.onPromiseResolve.emit(n,e,i,t,s,d),o(s)}))}))}return r.onPostCall.emit(n,e,i,a,d),a}}}const a={r8unorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8snorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8uint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8sint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg8unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8snorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},'rgba8unorm-srgb':{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8snorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},bgra8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},'bgra8unorm-srgb':{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r16uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16float:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg16uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba16uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r32uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg32uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba32uint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32sint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32float:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rg11b10ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},stencil8:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!1,hasStencil:!0,channels:1},depth16unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},depth24plus:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,depthOnlyFormat:'depth32float',channels:1},'depth24plus-stencil8':{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,depthOnlyFormat:'depth32float',channels:1},depth32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},'depth32float-stencil8':{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,stencilOnlyFormat:'depth32float',channels:1},rgb9e5ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},'bc1-rgba-unorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc1-rgba-unorm-srgb':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc2-rgba-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc2-rgba-unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc3-rgba-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc3-rgba-unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc4-r-unorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},'bc4-r-snorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},'bc5-rg-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},'bc5-rg-snorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},'bc6h-rgb-ufloat':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc6h-rgb-float':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc7-rgba-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc7-rgba-unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgb8unorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgb8unorm-srgb':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgb8a1unorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgb8a1unorm-srgb':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgba8unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgba8unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'eac-r11unorm':{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},'eac-r11snorm':{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},'eac-rg11unorm':{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},'eac-rg11snorm':{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},'astc-4x4-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'astc-4x4-unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'astc-5x4-unorm':{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},'astc-5x4-unorm-srgb':{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},'astc-5x5-unorm':{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},'astc-5x5-unorm-srgb':{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},'astc-6x5-unorm':{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},'astc-6x5-unorm-srgb':{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},'astc-6x6-unorm':{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},'astc-6x6-unorm-srgb':{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},'astc-8x5-unorm':{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},'astc-8x5-unorm-srgb':{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},'astc-8x6-unorm':{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},'astc-8x6-unorm-srgb':{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},'astc-8x8-unorm':{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},'astc-8x8-unorm-srgb':{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},'astc-10x5-unorm':{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},'astc-10x5-unorm-srgb':{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},'astc-10x6-unorm':{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},'astc-10x6-unorm-srgb':{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},'astc-10x8-unorm':{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},'astc-10x8-unorm-srgb':{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},'astc-10x10-unorm':{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},'astc-10x10-unorm-srgb':{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},'astc-12x10-unorm':{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},'astc-12x10-unorm-srgb':{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},'astc-12x12-unorm':{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4},'astc-12x12-unorm-srgb':{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4}};class c{constructor(e){this.device=e,this.blitShaderModule=e.createShaderModule({code:c.blitShader}),this.blit3dShaderModule=e.createShaderModule({code:c.blit3dShader}),this.multisampleBlitShaderModule=e.createShaderModule({code:c.multisampleBlitShader}),this.depthToFloatShaderModule=e.createShaderModule({code:c.depthToFloatShader}),this.depthToFloatMultisampleShaderModule=e.createShaderModule({code:c.depthToFloatMultisampleShader}),this.blitPipelines={},this.blitDepthPipelines={},this.bindGroupLayouts=new Map,this.pipelineLayouts=new Map,this.depthToFloatPipeline=null,this.depthToFloatMSPipeline=null,this.pointSampler=e.createSampler({magFilter:'nearest',minFilter:'nearest'}),this.displayUniformBuffer=e.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.displayBingGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:'uniform'}}]}),this.displayBindGroup=e.createBindGroup({layout:this.displayBingGroupLayout,entries:[{binding:0,resource:{buffer:this.displayUniformBuffer}}]})}copyDepthTexture(e,t,r){const s=e.width,n=e.height,o=e.depthOrArrayLayers,i=e.usage|GPUTextureUsage.RENDER_TARGET|GPUTextureUsage.COPY_SRC,a=[s,n,o];t=t||'r32float';const c=this.device.createTexture({format:t,size:a,usage:i});for(let s=0;s<o;++s){const n=e.createView({dimension:'2d',aspect:'depth-only',baseArrayLayer:s,arrayLayerCount:1}),o=c.createView({dimension:'2d',baseArrayLayer:s,arrayLayerCount:1});this.convertDepthToFloat(n,e.sampleCount,o,t,r)}return c}copyMultisampledTexture(e){const t=e.width,r=e.height,s=e.format,n=e.usage|GPUTextureUsage.RENDER_TARGET|GPUTextureUsage.COPY_SRC,o=[t,r,1],i=this.device.createTexture({format:s,size:o,usage:n});return this.blitTexture(e.createView(),e.format,e.sampleCount,i.createView(),s),i}blitTexture(e,t,r,s,n,o,i,c){c??=0,i??='2d';const d='unfilterable-float',p=`${d}#${r}#${i}`;if(!this.bindGroupLayouts.has(p)){const e=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{type:'non-filtering'}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:i,sampleType:d,multisampled:r>1}}]});this.bindGroupLayouts.set(p,e);const t=this.device.createPipelineLayout({bindGroupLayouts:[e,this.displayBingGroupLayout]});this.pipelineLayouts.set(p,t)}const u=a[t],l=u?.channels??4,h=this.bindGroupLayouts.get(p),_=this.pipelineLayouts.get(p),f=`${n}#${d}#${r}#${i}`;let m=this.blitPipelines[f];if(!m){const e=r>1?this.multisampleBlitShaderModule:'3d'===i?this.blit3dShaderModule:this.blitShaderModule;m=this.device.createRenderPipeline({layout:_,vertex:{module:e,entryPoint:'vertexMain'},fragment:{module:e,entryPoint:'fragmentMain',targets:[{format:n}]},primitive:{topology:'triangle-list'}}),this.blitPipelines[f]=m}const g=this.device.createBindGroup({layout:h,entries:[{binding:0,resource:this.pointSampler},{binding:1,resource:e}]}),b=this.device.createCommandEncoder(),y={colorAttachments:[{view:s,loadOp:'clear',storeOp:'store'}]};o?this.device.queue.writeBuffer(this.displayUniformBuffer,0,new Float32Array([o.exposure,o.channels,l,o.minRange,o.maxRange,c,0,0])):this.device.queue.writeBuffer(this.displayUniformBuffer,0,new Float32Array([1,0,l,0,1,c,0,0]));const P=b.beginRenderPass(y);P.setPipeline(m),P.setBindGroup(0,g),P.setBindGroup(1,this.displayBindGroup),P.draw(3),P.end(),this.device.queue.submit([b.finish()])}convertDepthToFloat(e,t,r,s,n){if(t>1){if(!this.depthToFloatMSPipeline){this.device.pushErrorScope('validation'),this.depthToFloatBindGroupMSLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:'depth',multisampled:!0}}]});const e=this.device.createPipelineLayout({bindGroupLayouts:[this.depthToFloatBindGroupMSLayout]}),t=this.depthToFloatMultisampleShaderModule;this.depthToFloatMSPipeline=this.device.createRenderPipeline({layout:e,vertex:{module:t,entryPoint:'vertexMain'},fragment:{module:t,entryPoint:'fragmentMain',targets:[{format:s}]},primitive:{topology:'triangle-list'}}),this.device.popErrorScope().then((e=>{e&&console.error(e.message)}))}}else if(!this.depthToFloatPipeline){this.device.pushErrorScope('validation'),this.depthToFloatBindGroupLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:'depth'}}]});const e=this.device.createPipelineLayout({bindGroupLayouts:[this.depthToFloatBindGroupLayout]}),t=this.depthToFloatShaderModule;this.depthToFloatPipeline=this.device.createRenderPipeline({layout:e,vertex:{module:t,entryPoint:'vertexMain'},fragment:{module:t,entryPoint:'fragmentMain',targets:[{format:s}]},primitive:{topology:'triangle-list'}}),this.device.popErrorScope().then((e=>{e&&console.error(e.message)}))}this.device.pushErrorScope('validation');const o=this.device.createBindGroup({layout:t>1?this.depthToFloatBindGroupMSLayout:this.depthToFloatBindGroupLayout,entries:[{binding:0,resource:e}]}),i=!n;n??=this.device.createCommandEncoder();const a=n.beginRenderPass({colorAttachments:[{view:r,loadOp:'clear',storeOp:'store',clearColor:{r:0,g:0,b:0,a:0}}]});a.setPipeline(t>1?this.depthToFloatMSPipeline:this.depthToFloatPipeline),a.setBindGroup(0,o),a.draw(3),a.end(),i&&this.device.queue.submit([n.finish()]),this.device.popErrorScope().then((e=>{e&&console.error(e.message)}))}}c.blitShader='\n  var<private> posTex:array<vec4f, 3> = array<vec4f, 3>(\n    vec4f(-1.0, 1.0, 0.0, 0.0),\n    vec4f(3.0, 1.0, 2.0, 0.0),\n    vec4f(-1.0, -3.0, 0.0, 2.0));\n  struct VertexOutput {\n    @builtin(position) position: vec4f,\n    @location(0) uv: vec2f\n  };\n  @vertex\n  fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var output: VertexOutput;\n    output.uv = posTex[vertexIndex].zw;\n    output.position = vec4f(posTex[vertexIndex].xy, 0.0, 1.0);\n    return output;;\n  }\n  @group(0) @binding(0) var texSampler: sampler;\n  @group(0) @binding(1) var texture: texture_2d<f32>;\n  struct Display {\n    exposure: f32,\n    channels: f32,\n    numChannels: f32,\n    minRange: f32,\n    maxRange: f32,\n    _pad1: f32,\n    _pad2: f32,\n    _pad3: f32\n  };\n  @group(1) @binding(0) var<uniform> display: Display; \n  @fragment\n  fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n    var color = textureSample(texture, texSampler, input.uv);\n\n    if (display.numChannels == 1.0) {\n      if (display.minRange != display.maxRange) {\n        if (color.r < display.minRange) {\n          color = vec4f(0.0, 0.0, 0.0, 1);\n        } else if (color.r > display.maxRange) {\n          color = vec4f(1.0, 0.0, 0.0, 1);\n        } else {\n          color = vec4f((color.r - display.minRange) / (display.maxRange - display.minRange), 0.0, 0.0, 1);\n        }\n      }\n      color = vec4f(color.r, color.r, color.r, 1.0);\n    } else if (display.numChannels == 2.0) {\n      color = vec4f(color.r, color.g, 0.0, 1.0);\n    }\n\n    if (display.channels == 1.0) { // R\n      var rgb = color.rgb * display.exposure;\n      return vec4f(rgb.r, 0.0, 0.0, 1);\n    } else if (display.channels == 2.0) { // G\n      var rgb = color.rgb * display.exposure;\n      return vec4f(0.0, rgb.g, 0.0, 1);\n    } else if (display.channels == 3.0) { // B\n      var rgb = color.rgb * display.exposure;\n      return vec4f(0.0, 0.0, rgb.b, 1);\n    } else if (display.channels == 4.0) { // A\n      var a = color.a * display.exposure;\n      return vec4f(a, a, a, 1);\n    } else if (display.channels == 5.0) { // Luminance\n      var luminance = dot(color.rgb, vec3f(0.2126, 0.7152, 0.0722));\n      var rgb = vec3f(luminance) * display.exposure;\n      return vec4f(rgb, 1);\n    }\n\n    // RGB\n    var rgb = color.rgb * display.exposure;\n    return vec4f(rgb, 1);\n  }\n',c.blit3dShader='\n  var<private> posTex:array<vec4f, 3> = array<vec4f, 3>(\n    vec4f(-1.0, 1.0, 0.0, 0.0),\n    vec4f(3.0, 1.0, 2.0, 0.0),\n    vec4f(-1.0, -3.0, 0.0, 2.0));\n  struct VertexOutput {\n    @builtin(position) position: vec4f,\n    @location(0) uv: vec2f\n  };\n  @vertex\n  fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var output: VertexOutput;\n    output.uv = posTex[vertexIndex].zw;\n    output.position = vec4f(posTex[vertexIndex].xy, 0.0, 1.0);\n    return output;;\n  }\n  @group(0) @binding(0) var texSampler: sampler;\n  @group(0) @binding(1) var texture: texture_3d<f32>;\n  struct Display {\n    exposure: f32,\n    channels: f32,\n    numChannels: f32,\n    minRange: f32,\n    maxRange: f32,\n    layer: f32,\n    _pad2: f32,\n    _pad3: f32\n  };\n  @group(1) @binding(0) var<uniform> display: Display; \n  @fragment\n  fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n    var color = textureSampleLevel(texture, texSampler, vec3f(input.uv, display.layer), 0.0);\n\n    if (display.numChannels == 1.0) {\n      if (display.minRange != display.maxRange) {\n        if (color.r < display.minRange) {\n          color = vec4f(0.0, 0.0, 0.0, 1);\n        } else if (color.r > display.maxRange) {\n          color = vec4f(1.0, 0.0, 0.0, 1);\n        } else {\n          color = vec4f((color.r - display.minRange) / (display.maxRange - display.minRange), 0.0, 0.0, 1);\n        }\n      }\n      color = vec4f(color.r, color.r, color.r, 1.0);\n    } else if (display.numChannels == 2.0) {\n      color = vec4f(color.r, color.g, 0.0, 1.0);\n    }\n\n    if (display.channels == 1.0) { // R\n      var rgb = color.rgb * display.exposure;\n      return vec4f(rgb.r, 0.0, 0.0, 1);\n    } else if (display.channels == 2.0) { // G\n      var rgb = color.rgb * display.exposure;\n      return vec4f(0.0, rgb.g, 0.0, 1);\n    } else if (display.channels == 3.0) { // B\n      var rgb = color.rgb * display.exposure;\n      return vec4f(0.0, 0.0, rgb.b, 1);\n    } else if (display.channels == 4.0) { // A\n      var a = color.a * display.exposure;\n      return vec4f(a, a, a, 1);\n    } else if (display.channels == 5.0) { // Luminance\n      var luminance = dot(color.rgb, vec3f(0.2126, 0.7152, 0.0722));\n      var rgb = vec3f(luminance) * display.exposure;\n      return vec4f(rgb, 1);\n    }\n\n    // RGB\n    var rgb = color.rgb * display.exposure;\n    return vec4f(rgb, 1);\n  }\n',c.multisampleBlitShader='\n  var<private> posTex:array<vec4f, 3> = array<vec4f, 3>(\n    vec4f(-1.0, 1.0, 0.0, 0.0),\n    vec4f(3.0, 1.0, 2.0, 0.0),\n    vec4f(-1.0, -3.0, 0.0, 2.0));\n  struct VertexOutput {\n    @builtin(position) position: vec4f,\n    @location(0) uv: vec2f\n  };\n  @vertex\n  fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var output: VertexOutput;\n    output.uv = posTex[vertexIndex].zw;\n    output.position = vec4f(posTex[vertexIndex].xy, 0.0, 1.0);\n    return output;;\n  }\n  @group(0) @binding(0) var texSampler: sampler;\n  @group(0) @binding(1) var texture: texture_multisampled_2d<f32>;\n  struct Display {\n    exposure: f32,\n    channels: f32,\n    numChannels: f32,\n    minRange: f32,\n    maxRange: f32,\n    _pad1: f32,\n    _pad2: f32,\n    _pad3: f32\n  };\n  @group(1) @binding(0) var<uniform> display: Display; \n  @fragment\n  fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n    var coords = vec2i(input.uv * vec2f(textureDimensions(texture)));\n    var color = textureLoad(texture, coords, 0);\n    if (display.numChannels == 1.0) {\n      if (display.minRange != display.maxRange) {\n        if (color.r < display.minRange) {\n          color = vec4f(0.0, 0.0, 0.0, color.a);\n        } else if (color.r > display.maxRange) {\n          color = vec4f(1.0, 1.0, 1.0, color.a);\n        } else {\n          color = vec4f((color.r - display.minRange) / (display.maxRange - display.minRange), 0.0, 0.0, color.a);\n        }\n      }\n      color = vec4f(color.r, color.r, color.r, 1.0);\n    } else if (display.numChannels == 2.0) {\n      color = vec4f(color.r, color.g, 0.0, 1.0);\n    }\n    if (display.channels == 1.0) { // R\n      var rgb = color.rgb * display.exposure;\n      return vec4f(rgb.r, 0.0, 0.0, color.a);\n    } else if (display.channels == 2.0) { // G\n      var rgb = color.rgb * display.exposure;\n      return vec4f(0.0, rgb.g, 0.0, color.a);\n    } else if (display.channels == 3.0) { // B\n      var rgb = color.rgb * display.exposure;\n      return vec4f(0.0, 0.0, rgb.b, color.a);\n    } else if (display.channels == 4.0) { // A\n      var a = color.a * display.exposure;\n      return vec4f(a, a, a, color.a);\n    } else if (display.channels == 5.0) { // Luminance\n      var luminance = dot(color.rgb, vec3f(0.2126, 0.7152, 0.0722));\n      var rgb = vec3f(luminance) * display.exposure;\n      return vec4f(rgb, color.a);\n    }\n\n    // RGB\n    var rgb = color.rgb * display.exposure;\n    return vec4f(rgb, color.a);\n  }',c.depthToFloatShader='\n  var<private> posTex:array<vec4f, 3> = array<vec4f, 3>(\n    vec4f(-1.0, 1.0, 0.0, 0.0),\n    vec4f(3.0, 1.0, 2.0, 0.0),\n    vec4f(-1.0, -3.0, 0.0, 2.0));\n  struct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n  @vertex\n  fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var output: VertexOutput;\n    output.uv = posTex[vertexIndex].zw;\n    output.position = vec4f(posTex[vertexIndex].xy, 0.0, 1.0);\n    return output;;\n  }\n  \n  @binding(0) @group(0) var depth: texture_depth_2d;\n  @fragment\n  fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {\n    var depthSize = textureDimensions(depth);\n    var coords = vec2<i32>(i32(f32(depthSize.x) * input.uv.x),\n                           i32(f32(depthSize.y) * input.uv.y));\n    var d = textureLoad(depth, coords, 0);\n    return vec4<f32>(d, 0.0, 0.0, 1.0);\n  }',c.depthToFloatMultisampleShader='\n  var<private> posTex:array<vec4f, 3> = array<vec4f, 3>(\n    vec4f(-1.0, 1.0, 0.0, 0.0),\n    vec4f(3.0, 1.0, 2.0, 0.0),\n    vec4f(-1.0, -3.0, 0.0, 2.0));\n  struct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n  @vertex\n  fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var output: VertexOutput;\n    output.uv = posTex[vertexIndex].zw;\n    output.position = vec4f(posTex[vertexIndex].xy, 0.0, 1.0);\n    return output;;\n  }\n  \n  @binding(0) @group(0) var depth: texture_depth_multisampled_2d;\n  @fragment\n  fn fragmentMain(input: VertexOutput) -> @location(0) vec4<f32> {\n    var depthSize = textureDimensions(depth);\n    var coords = vec2<i32>(i32(f32(depthSize.x) * input.uv.x),\n                           i32(f32(depthSize.y) * input.uv.y));\n    var d = textureLoad(depth, coords, 0);\n    return vec4<f32>(d, 0.0, 0.0, 1.0);\n  }';const d={CaptureBufferData:'webgpu_inspect_capture_buffer_data',CaptureBuffers:'webgpu_inspect_capture_buffers',DeleteObjects:'webgpu_inspect_delete_objects',ValidationError:'webgpu_inspect_validation_error',MemoryLeakWarning:'webgpu_inspect_memory_leak_warning',DeltaTime:'webgpu_inspect_delta_time',CaptureFrameResults:'webgpu_inspect_capture_frame_results',CaptureFrameCommands:'webgpu_inspect_capture_frame_commands',ObjectSetLabel:'webgpu_inspect_object_set_label',AddObject:'webgpu_inspect_add_object',ResolveAsyncObject:'webgpu_inspect_resolve_async_object',DeleteObject:'webgpu_inspect_delete_object',CaptureTextureFrames:'webgpu_inspect_capture_texture_frames',CaptureTextureData:'webgpu_inspect_capture_texture_data',CaptureBufferData:'webgpu_inspect_capture_buffer_data',WriteBuffer:'wrebgpu_inspect_write_buffer',Recording:'webgpu_record_recording',RecordingCommand:'webgpu_record_command',RecordingDataCount:'webgpu_record_data_count',RecordingData:'webgpu_record_data'};d.values=new Set(Object.values(d));class p{constructor(e){this.windowSize=e,this.buffer=[],this.sum=0}add(e){this.buffer.push(e),this.buffer.length>this.windowSize&&(this.sum-=this.buffer.shift()),this.sum+=e}get average(){return 0===this.buffer.length?0:this.sum/this.buffer.length}}function u(e,t){return e+t-1&~(t-1)}e.webgpuInspector=null,(()=>{const r=self,s=self.window,o=self.document,l=self.sessionStorage,h=self.postMessage,_=self.dispatchEvent,f='WEBGPU_INSPECTOR_CAPTURE_FRAME',m=262144;e.webgpuInspector=new class e{constructor(){if(this._captureFrameCommands=[],this._frameData=[],this._frameRenderPassCount=0,this._captureTexturedBuffers=[],this._currentFrame=null,this._frameIndex=0,this._initalized=!0,this._objectID=1,this._lastFrameTime=0,this._frameCommandCount=0,this._captureFrameRequest=!1,this._errorChecking=1,this._trackedObjects=new Map,this._trackedObjectInfo=new Map,this._bindGroupCount=0,this._captureTextureRequest=new Map,this._toDestroy=[],this._objectReplacementMap=new Map,this._captureBuffersCount=0,this._captureTempBuffers=[],this._mappedTextureBufferCount=0,this._encodingTextureChunkCount=0,this._mappedBufferCount=0,this._encodingBufferChunkCount=0,this._captureData=null,this._frameRate=new p(60),this._captureTimestamps=!1,this._timestampQuerySet=null,this._timestampBuffer=null,this._timestampIndex=0,this._maxTimestamps=2e3,this._captureFrameCount=0,this._pendingMapCount=0,this._hasPendingDeviceDestroy=!1,!navigator.gpu)return;const e=this;if(o?.body?this.createStatusElements():o&&o.addEventListener('DOMContentLoaded',(()=>{e.createStatusElements();const t=o.getElementsByTagName('iframe');if(t.length>0)for(const e of t)e.addEventListener('load',(()=>{e.contentWindow.dispatchEvent(new CustomEvent('__WebGPUInspector',{detail:{__webgpuInspector:!0,action:'webgpu_inspector_start_inspection'}}))}));const r=o.getElementsByTagName('canvas');for(const t of r)e._wrapCanvas(t)})),this._gpuWrapper=new i(this),this._gpuWrapper.onPromise.addListener(this._onAsyncPromise,this),this._gpuWrapper.onPromiseResolve.addListener(this._onAsyncResolve,this),this._gpuWrapper.onPreCall.addListener(this._preMethodCall,this),this._gpuWrapper.onPostCall.addListener(this._postMethodCall,this),this._garbageCollectectedObjects=[],this._garbageCollectionRegistry=new FinalizationRegistry((t=>{if(t>0){e._garbageCollectectedObjects.push(t);const r=e._trackedObjectInfo.get(t);r&&(r===GPUBindGroup&&e._bindGroupCount--,r!==GPUBuffer&&r!==GPUTexture&&r!==GPUDevice||e._memoryLeakWarning(t,r),r===GPUDevice&&e._captureFrameCommands.length&&e._sendCapturedCommands()),e._garbageCollectectedObjects.length>100&&(e._postMessage({action:d.DeleteObjects,idList:e._garbageCollectectedObjects}),e._garbageCollectectedObjects.length=0)}t>0&&(e._trackedObjects.delete(t),e._trackedObjectInfo.delete(t),e._captureTextureRequest.delete(t),e._objectReplacementMap.delete(t))})),setInterval((()=>{e._garbageCollectectedObjects.length>0&&(e._postMessage({action:d.DeleteObjects,idList:e._garbageCollectectedObjects}),e._garbageCollectectedObjects.length=0)}),200),o){const t=o.getElementsByTagName('canvas');for(const e of t)this._wrapCanvas(e);const r=o.createElement;o.createElement=t=>{const s=r.call(o,t);return'canvas'===t?e._wrapCanvas(s):'iframe'===t&&s.addEventListener('load',(()=>{s.contentWindow.dispatchEvent(new CustomEvent('__WebGPUInspector',{detail:{__webgpuInspector:!0,action:'webgpu_inspector_start_inspection'}}))})),s}}const t=requestAnimationFrame;function n(t){let r=t.detail||t.data;if(r?.__WebGPUInspector&&(r=r.__WebGPUInspector),'object'==typeof r&&r.__webgpuInspector)if(r.action===d.DeltaTime)r.__webgpuInspectorWorker&&e._updateFrameRate(r.deltaTime);else if('webgpu_inspect_request_texture'===r.action){const t=r.id,s=r.mipLevel??0;e._requestTexture(t,s)}else if('webgpu_inspect_compile_shader'===r.action){const t=r.id,s=r.code;e._compileShader(t,s)}else if('webgpu_inspect_revert_shader'===r.action){const t=r.id;e._revertShader(t)}else'webgpu_inspector_capture'===r.action&&null==s&&('String'===r.data.constructor.name&&(r.data=JSON.parse(r.data)),e._captureData=r.data)}if(this._currentFrameTime=0,requestAnimationFrame=r=>t((t=>{if(!e._currentFrameTime){e._currentFrameTime=t,e._frameStart(t);const s=r(t);s instanceof Promise?Promise.all([s]).then((()=>{e._frameEnd(t),e._currentFrameTime=0})):(e._frameEnd(t),e._currentFrameTime=0)}})),s?r.addEventListener('__WebGPUInspector',n):r.addEventListener('message',n),l){const t=l.getItem(f);if(t){try{this._captureData=JSON.parse(t)}catch(e){this._captureData=null}l.removeItem(f)}}this._captureData&&this._initCaptureData()}createStatusElements(){const e=o.createElement('div');e.style='position: absolute; top: 0px; left: 0px; z-index: 1000000; margin-left: 10px; margin-top: 5px; padding-left: 5px; padding-right: 10px; background-color: rgba(0, 0, 1, 0.75); border-radius: 5px; box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.5); color: #fff; font-size: 12pt;',o.body.insertBefore(e,o.body.firstChild),this._inspectingStatus=o.createElement('div'),this._inspectingStatus.title='WebGPU Inspector Running',this._inspectingStatus.style='height: 10px; width: 10px; display: inline-block; margin-right: 5px; background-color: #ff0; border-radius: 50%; border: 1px solid #000; box-shadow: inset -4px -4px 4px -3px rgb(255,100,0), 2px 2px 3px rgba(0,0,0,0.8);',e.appendChild(this._inspectingStatus),this._inspectingStatusFrame=o.createElement('div'),this._inspectingStatusFrame.style='display: inline-block; cursor: pointer;',this._inspectingStatusFrame.textContent='Frame: 0',e.appendChild(this._inspectingStatusFrame),this._inspectingStatusText=o.createElement('div'),this._inspectingStatusText.style='display: inline-block; margin-left: 10px; cursor: pointer;',e.appendChild(this._inspectingStatusText);const t=this;e.addEventListener('click',(()=>{t._captureFrameRequest&&t._sendCapturedCommands()}))}captureWorker(e){this._wrapCanvas(e)}disableRecording(){this._gpuWrapper.disableRecording()}enableRecording(){this._gpuWrapper.enableRecording()}_postMessage(e){e.__webgpuInspector=!0,e.__webgpuInspectorPage=!0,e.__webgpuInspectorWorker=!s,s?_(new CustomEvent('__WebGPUInspector',{detail:e})):h({__WebGPUInspector:e})}_updateCanvasAttachment(e){let t=null;e.resolveTarget?t=e.resolveTarget:e.view&&(t=e.view);const r=t?.__texture,s=r?.__context;if(!s)return;s.__captureTexture&&(s.__captureTexture.width==r.width&&s.__captureTexture.height==r.height&&s.__captureTexture.format==r.format||(this.disableRecording(),s.__captureTexture.destroy(),s.__captureTexture=null,this.enableRecording()));const n=s.__device;if(n){this.disableRecording();const o=n.createTexture({size:[r.width,r.height,1],format:r.format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});if(s.__captureTexture=o,o){o.__id=r.__id,o.__canvasTexture=r,o.__context=s;const n=o.createView();n.__texture=o,n.__canvasView=t,o.__view=n,n.__context=s,e.resolveTarget?e.resolveTarget=n:e.view=n}this.enableRecording()}}_preMethodCall(e,t,r){if('destroy'===t&&e===this._device?.deref()&&this._pendingMapCount)return this._hasPendingDeviceDestroy=!0,!0;if('requestDevice'===t&&0===r.length&&(r[0]={}),'setPipeline'===t){let e=r[0];const t=this._objectReplacementMap.get(e.__id);t&&t.replacement&&(r[0]=t.replacement)}if('createTexture'===t&&(r[0].usage|=GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),'createBuffer'===t&&(r[0].usage&GPUBufferUsage.MAP_READ||(r[0].usage|=GPUBufferUsage.COPY_SRC)),'createShaderModule'!==t&&'createRenderPipeline'!==t&&'createComputePipeline'!==t&&'createBindGroup'!==t||this._errorChecking>0&&(this._gpuWrapper.disableRecording(),e.pushErrorScope('validation'),this._gpuWrapper.enableRecording()),'beginRenderPass'!==t&&'beginComputePass'!==t||this._captureTimestamps&&this._captureFrameRequest&&(!this._timestampQuerySet&&e.__device&&(this._timestampQuerySet=e.__device.createQuerySet({type:'timestamp',count:this._maxTimestamps}),this._timestampBuffer=e.__device.createBuffer({size:8*this._maxTimestamps,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC})),!r[0].timestampWrites&&this._timestampIndex<this._maxTimestamps&&(r[0].timestampWrites={querySet:this._timestampQuerySet,beginningOfPassWriteIndex:this._timestampIndex,endOfPassWriteIndex:this._timestampIndex+1},this._timestampIndex+=2)),e instanceof GPUCanvasContext&&'configure'===t){const t=r[0];t.usage?t.usage|=GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC:t.usage=GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,e.__device=t.device}}_postMethodCall(e,t,r,s,o){if(this._frameCommandCount++,e instanceof GPURenderBundleEncoder&&'finish'!==t){void 0===e._commands&&(e._commands=[]);const n=this._processCommandArgs(r);e._commands.push({method:t,args:n,result:s})}if('beginRenderPass'===t){s.__commandEncoder=e;for(const t of r[0].colorAttachments){if(!t)continue;const r=t.resolveTarget??t.view;if(r&&r.__id<0){if(e.__rendersToCanvas=!0,r.__texture.__frameIndex<this._frameIndex){const e='An expired canvas texture is being used as an attachment for a RenderPass.';this._postMessage({action:d.ValidationError,id:0,message:e,stacktrace:o})}break}}}if('finish'===t&&e instanceof GPURenderBundleEncoder&&(s._commands=e._commands),'finish'===t&&e instanceof GPUCommandEncoder&&(s.__rendersToCanvas=e.__rendersToCanvas),'submit'===t){this.disableRecording();let t=null;if(this._timestampIndex>0){const r=e.__device.createCommandEncoder();r.resolveQuerySet(this._timestampQuerySet,0,this._timestampIndex,this._timestampBuffer,0),t=e.__device.createBuffer({size:8*this._timestampIndex,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),t.__count=this._timestampIndex,r.copyBufferToBuffer(this._timestampBuffer,0,t,0,8*this._timestampIndex),e.__device.queue.submit([r.finish()]),this._timestampIndex=0}const s=this;if(this._captureTextureRequest.size>0){const t=r[0];let n=!1;for(const e of t)n|=!!e.__rendersToCanvas;this._captureTextureRequest.forEach(((t,r)=>{const o=r,i=t?.mipLevel??0;if(o>0||n){const r=t?.texture||s._trackedObjects.get(o)?.deref();if(-1===i){const t=r.mipLevelCount??1;for(let n=0;n<t;++n)s._captureTextureBuffer(e.__device,null,r,void 0,n)}else s._captureTextureBuffer(e.__device,null,r,void 0,i);s._captureTextureRequest.delete(o)}}))}const n=[...this._captureTempBuffers];this._captureTempBuffers.length=0;const o=[...this._captureTexturedBuffers];this._captureTexturedBuffers.length=0;const i=[...this._toDestroy];this._toDestroy.length=0,this._pendingMapCount+=n.length+o.length,e.onSubmittedWorkDone().then((async()=>{s.disableRecording(),t&&s._sendTimestampBuffer(t.__count,t),n.length&&s._sendCapturedBuffers(n),o.length&&s._sendCaptureTextureBuffers(o);for(const e of i)e.destroy();s.enableRecording()})),this.enableRecording()}if(('createShaderModule'===t||'createRenderPipeline'===t||'createComputePipeline'===t||'createBindGroup'===t)&&this._errorChecking>0){this.disableRecording();const t=this;e.popErrorScope().then((e=>{if(e){console.error(e.message);const r=s?.__id??0;t._postMessage({action:d.ValidationError,id:r,message:e.message,stacktrace:o})}})),this.enableRecording()}let i;if('getCurrentTexture'===t?(e.__id||(this._wrapObject(e),this._trackObject(e.__id,e)),i=-e.__id,e.__canvasTexture=new WeakRef(s),s.__frameIndex=this._frameIndex):'createView'===t&&e.__id<0&&(i=e.__id-.5),e instanceof GPUDevice&&void 0===e?.__id&&(this._wrapDevice(null,e),e.__adapter||navigator.gpu.requestAdapter().then((t=>{e.__adapter=t}))),s)if(n.has(s.constructor)&&this._wrapObject(s,i),'createShaderModule'===t||'createRenderPipeline'===t)s.__descriptor=r[0],s.__device=e,this._objectReplacementMap.set(s.__id,{id:s.__id,object:new WeakRef(s),replacement:null});else if('createRenderBundleEncoder'===t)s.__descriptor=r[0],s.__device=e;else if('getCurrentTexture'===t)s.__context=e,this._trackObject(s.__id,s),s.label='CanvasTexture';else if('createTexture'===t)this._trackObject(s.__id,s);else if('createView'!==t||i){if('createBuffer'===t)this._trackObject(s.__id,s);else if('createBindGroup'===t)this._trackObject(s.__id,s),s.__descriptor=r[0];else if('setBindGroup'===t){const t=r[1].__descriptor;if(t)for(const r of t.entries)if(r.resource instanceof GPUTextureView&&r.resource.__id<0&&r.resource.__texture.__frameIndex<this._frameIndex){const t=`A BindGroup(${e.__id}) with an expired canvas texture is being used.`;this._postMessage({action:d.ValidationError,id:0,message:t,stacktrace:o})}}}else this._trackObject(s.__id,s),s.__texture=e,s.__id<0&&(s.label='CanvasTextureView');this._recordCommand(e,t,s,r,o)}_onAsyncPromise(e,t,r,s,n){switch(t){case'createRenderPipelineAsync':this._sendAddObjectMessage(s,e.__id,'RenderPipeline',this._stringifyDescriptor(r[0]),n,!0);break;case'createComputePipelineAsync':this._sendAddObjectMessage(s,e.__id,'ComputePipeline',this._stringifyDescriptor(r[0]),n,!0);break;default:this._postMethodCall(e,t,r,s,n)}}_onAsyncResolve(e,t,r,s,n,o){if('requestAdapter'===t)n&&this._wrapAdapter(n,s,o);else if('requestDevice'===t){const t=e,i=n;i&&this._wrapDevice(t,i,s,r,o)}else n&&(this._wrapObject(n,s),this._postMessage({action:d.ResolveAsyncObject,id:n.__id}))}_wrapAdapter(e,t,r){this._wrapObject(e,t),t??=e.__id;const s=this;if(e.info){const n={vendor:e.info.vendor,device:e.info.device,description:e.info.description,features:s._gpuToArray(e.info.features),limits:s._gpuToObject(e.info.limits),isFallbackAdapter:e.info.isFallbackAdapter,wgslFeatures:s._gpuToArray(navigator.gpu.wgslLanguageFeatures)};s._sendAddObjectMessage(t,0,'Adapter',JSON.stringify(n),r)}else e.requestAdapterInfo&&e.requestAdapterInfo().then((n=>{const o={vendor:n.vendor,architecture:n.architecture,device:n.device,description:n.description,features:s._gpuToArray(e.features),limits:s._gpuToObject(e.limits),isFallbackAdapter:e.isFallbackAdapter,wgslFeatures:s._gpuToArray(navigator.gpu.wgslLanguageFeatures)};s._sendAddObjectMessage(t,0,'Adapter',JSON.stringify(o),r)}))}_wrapDevice(e,t,r,s,n){if(e&&void 0===e.__id&&this._wrapAdapter(e,void 0,n),t&&void 0===t.__id){t.queue.__device=t;const o=this;t.addEventListener('uncapturederror',(e=>{o._postMessage({action:d.ValidationError,id:0,message:e.error.message})})),s??=[],this._wrapObject(t,r);const i=s[0]??{},a=t.__id,c=e?.__id??0;i.features=this._gpuToArray(t.features),i.limits=this._gpuToObject(t.limits),this._trackObject(a,t),this._sendAddObjectMessage(r,c,'Device',JSON.stringify(i),n),t.__adapter=e,this._device=new WeakRef(t)}}clear(){this._captureFrameCommands.length=0,this._currentFrame=null}getNextId(e){return e instanceof GPUCommandEncoder||e instanceof GPUComputePassEncoder||e instanceof GPURenderPassEncoder||e instanceof GPUCommandBuffer?0:this._objectID++}_memoryLeakWarning(e,t){if(t){const e=`${t.name} was garbage collected without being explicitly destroyed. These objects should explicitly destroyed to avoid GPU memory leaks.`;this._postMessage({action:d.ValidationError,id:0,message:e})}}_isPrimitiveType(e){return!e||e.constructor===String||e.constructor===Number||e.constructor===Boolean}_isTypedArray(e){return e&&(e instanceof ArrayBuffer||e.buffer instanceof ArrayBuffer)}_isArray(e){return e&&e.constructor===Array}_duplicateArray(e,t){const r=new Array(e.length);for(let s=0,n=e.length;s<n;++s){const n=e[s];this._isPrimitiveType(n)?r[s]=n:void 0!==n.__id?r[s]=t?{__id:n.__id,__class:n.constructor.name}:n:this._isTypedArray(n)?r[s]=n:this._isArray(n)?r[s]=this._duplicateArray(n,t):r[s]=n instanceof Object?this._duplicateObject(n,t):n}return r}_duplicateObject(e,t){const r={};for(const s in e){if(s.startsWith('_'))continue;const n=e[s];void 0!==n&&(this._isPrimitiveType(n)?r[s]=n:void 0!==n.__id?r[s]=t?{__id:n.__id,__class:n.constructor.name}:n:void 0!==n.label||this._isTypedArray(n)?r[s]=n:this._isArray(n)?r[s]=this._duplicateArray(n,t):r[s]=n instanceof Object?this._duplicateObject(n,t):n)}return r}_revertShader(e){const t=this._objectReplacementMap.get(e);if(!t)return;const r=t.object?.deref();if(r){t.replacement=null;for(const e of this._objectReplacementMap.values()){const t=e.object.deref(),s=t instanceof GPURenderPipeline,n=t instanceof GPUComputePipeline;if(s||n){const s=t.__descriptor;let n=!1;s.vertex?.module===r&&(n=!0),s.fragment?.module===r&&(n=!0),s.compute?.module===r&&(n=!0),n&&(e.replacement=null)}}}}_compileShader(e,t){const r=this._objectReplacementMap.get(e);if(!r)return;const s=r.object?.deref();if(!s)return;const n=s.__device,o=this._duplicateObject(s.__descriptor);o.code=t,this.disableRecording(),this._errorChecking--,n.pushErrorScope('validation'),o.__replacement=e;const i=n.createShaderModule(o),a=this;n.popErrorScope().then((t=>{if(t){console.error(t.message);const r=e??0;a._postMessage({action:d.ValidationError,id:r,message:t.message})}})),this._errorChecking++,this.enableRecording(),r.replacement=i;for(const e of this._objectReplacementMap.values()){const t=e.object.deref(),r=t instanceof GPURenderPipeline,o=t instanceof GPUComputePipeline;if(r||o){const o=t.__descriptor;let a=!1,c=null;if(o.vertex?.module===s&&(c||(c=this._duplicateObject(o)),a=!0,c.vertex.module=i),o.fragment?.module===s&&(c||(c=this._duplicateObject(o)),a=!0,c.fragment.module=i),o.compute?.module===s&&(c||(c=this._duplicateObject(o)),a=!0,c.compute.module=i),a){this.disableRecording(),this._errorChecking--,c.__replacement=e.id,n.pushErrorScope('validation');const t=r?n.createRenderPipeline(c):n.createComputePipeline(c),s=this;n.popErrorScope().then((t=>{if(t){console.error(t.message);const r=e.id??0;s._postMessage({action:d.ValidationError,id:r,message:t.message})}})),this._errorChecking++,this.enableRecording(),e.replacement=t}}}}_requestTexture(e,t){if(t=parseInt(t||0)||0,e<0)this._captureTextureRequest.set(e,null);else{const r=this._trackedObjects.get(e),s=r?.deref();s instanceof GPUTexture&&this._captureTextureRequest.set(e,{texture:s,mipLevel:t})}}_updateStatusMessage(){if(!this._inspectingStatusFrame)return;let e='';this._captureTexturedBuffers.length>0&&(e+=`Texture: ${this._captureTexturedBuffers.length} `),this._mappedTextureBufferCount>0&&(e+=`Pending Texture Reads: ${this._mappedTextureBufferCount} `),this._encodingTextureChunkCount>0&&(e+=`Pending Texture Encoding: ${this._encodingTextureChunkCount} `),this._captureBuffersCount&&(e+=`Buffers: ${this._captureBuffersCount} `),this._mappedBufferCount>0&&(e+=`Pending Buffer Reads: ${this._mappedBufferCount} `),this._encodingBufferChunkCount>0&&(e+=`Pending Buffer Encoding: ${this._encodingBufferChunkCount} `),e&&(e=`Capturing: ${e} `),this._captureFrameRequest?(e=`Recording (click to stop): ${e}`,this._inspectingStatusText.title='Click to stop recording'):this._inspectingStatusText.title='',this._inspectingStatusText.textContent=e}_updateFrameRate(e){this._frameRate.add(e),this._frameIndex++,this._inspectingStatusFrame&&this._updateFrameStatus()}_updateFrameStatus(){if(this._inspectingStatusFrame){let e=`Frame: ${this._frameIndex}`;const t=this._frameRate.average;0!==t&&(e+=` : ${t.toFixed(2)}ms`),this._inspectingStatusFrame.textContent=e}}_initCaptureData(){if((this._captureData.frame<0||this._frameIndex>=this._captureData.frame)&&(this._captureMaxBufferSize=this._captureData.maxBufferSize||262144,this._captureFrameCount=this._captureData.captureFrameCount||1,this._captureFrameRequest=!0,this._gpuWrapper.recordStacktraces=!0,this._captureData=null,this._updateStatusMessage(),this._captureTimestamps)){this.disableRecording();const e=this._device?.deref();if(e){this._timestampQuerySet||(this._timestampQuerySet=e.createQuerySet({type:'timestamp',count:this._maxTimestamps}),this._timestampBuffer=e.createBuffer({size:8*this._maxTimestamps,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}));const t=e.createCommandEncoder();t.beginComputePass({timestampWrites:{querySet:this._timestampQuerySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}}).end(),e.queue.submit([t.finish()]),this._timestampIndex=2}this.enableRecording()}}_frameStart(e){let t=0;if(0==this._lastFrameTime?this._lastFrameTime=e:(t=e-this._lastFrameTime,this._postMessage({action:d.DeltaTime,deltaTime:t}),this._lastFrameTime=e,this._frameRate.add(t)),l){const t=l.getItem(f);if(t){try{this._captureData=JSON.parse(t)}catch(e){this._captureData=null}l.removeItem(f)}}this._captureData&&this._initCaptureData(),this._captureFrameCount<=0&&(this._frameData.length=0,this._captureFrameCommands.length=0,this._frameRenderPassCount=0,this._frameIndex++,this._frameCommandCount=0),this._inspectingStatusFrame&&(this._updateFrameStatus(),this._updateStatusMessage())}_sendCapturedCommands(){const e=2e3,t=Math.ceil(this._captureFrameCommands.length/e);this._postMessage({action:d.CaptureFrameResults,frame:this._frameIndex,count:this._captureFrameCommands.length,batches:t});for(let t=0;t<this._captureFrameCommands.length;t+=e){const r=Math.min(e,this._captureFrameCommands.length-t),s=this._captureFrameCommands.slice(t,t+r);this._postMessage({action:d.CaptureFrameCommands,frame:this._frameIndex-1,commands:s,index:t,count:r})}this._captureFrameCommands.length=0,this._captureFrameRequest=!1,this._gpuWrapper.recordStacktraces=!1,this._updateStatusMessage()}_frameEnd(e){this._captureFrameCommands.length&&(this._captureFrameCount--,this._captureFrameCount<=0&&this._sendCapturedCommands()),this._updateStatusMessage()}_trackObject(e,t){this._trackedObjects.set(e,new WeakRef(t)),this._trackedObjectInfo.set(e,t.constructor)}_wrapCanvas(e){if(e.__id)return;e.__id=this.getNextId(e),this._trackObject(e.__id,e);const t=this,r=e.getContext;e.getContext=(s,n)=>{const o=r.call(e,s,n);return o instanceof GPUCanvasContext&&(t._wrapObject(o),t._trackObject(o.__id,o)),o}}_wrapObject(e,t){if(e&&void 0===e.__id){if(e.__id=t??this.getNextId(e),this._garbageCollectionRegistry.register(e,e.__id),void 0!==e.label){const t=e.label;e._label=t;const r=this;Object.defineProperty(e,'label',{enumerable:!0,configurable:!0,get(){return this._label},set(e){if(e!==this._label){this._label=e;const t=this.__id;r._postMessage({action:d.ObjectSetLabel,id:t,label:e})}}})}e instanceof GPUDevice&&void 0===e.queue.__id&&this._wrapObject(e.queue)}}_gpuToArray(e){const t=[];if(e)for(const r of e)t.push(r);return t}_gpuToObject(e){const t={};if(e)for(const r in e)t[r]=e[r];return t}_stringifyDescriptor(e){const t=this._duplicateObject(e,!0)??{};let r=null;try{r=JSON.stringify(t)}catch(e){console.log(e.message)}return r}_sendAddObjectMessage(e,t,r,s,n,o){this._postMessage({action:d.AddObject,id:e,parent:t,type:r,descriptor:s,stacktrace:n,pending:o})}_detroyDevice(){this._device.deref()?.destroy()}_recordCommand(e,t,r,s,n){const o=e?.__id??0;if('destroy'===t){e===this._device?.deref()&&(this._captureFrameCommands.length&&this._sendCapturedCommands(),this._device=null);const t=e.__id;e.__destroyed=!0,t>0&&(this._trackedObjects.delete(t),this._trackedObjectInfo.delete(t),this._objectReplacementMap.delete(t)),e instanceof GPUBindGroup&&this._bindGroupCount--,t>=0&&(this._captureTextureRequest.delete(t),this._postMessage({action:d.DeleteObject,id:t}))}else if('createShaderModule'===t){const e=r.__id;s[0].__replacement||this._sendAddObjectMessage(e,o,'ShaderModule',this._stringifyDescriptor(s[0]),n)}else if('createBuffer'===t){const e=r.__id;this._sendAddObjectMessage(e,o,'Buffer',this._stringifyDescriptor(s[0]),n)}else if('createTexture'===t){const t=r.__id;this._sendAddObjectMessage(t,o,'Texture',this._stringifyDescriptor(s[0]),n),r.__device=e}else if('getCurrentTexture'===t){const e=r.__id;if(r){const t={size:[r.width,r.height,r.depthOrArrayLayers],mipLevelCount:r.mipLevelCount,sampleCount:r.sampleCount,dimension:r.dimension,format:r.format,usage:r.usage},s=JSON.stringify(t);this._sendAddObjectMessage(e,o,'Texture',s,n)}}else if('createView'===t){const t=r.__id;r.__texture=e,this._sendAddObjectMessage(t,o,'TextureView',this._stringifyDescriptor(s[0]),n)}else if('createSampler'===t){const e=r.__id;this._sendAddObjectMessage(e,o,'Sampler',this._stringifyDescriptor(s[0]),n)}else if('createBindGroup'===t){this._bindGroupCount++;const e=r.__id;r.__descriptor=s[0],this._sendAddObjectMessage(e,o,'BindGroup',this._stringifyDescriptor(s[0]),n)}else if('createBindGroupLayout'===t){const e=r.__id;r.__descriptor=s[0],this._sendAddObjectMessage(e,o,'BindGroupLayout',this._stringifyDescriptor(s[0]),n)}else if('createPipelineLayout'===t){const e=r.__id;this._sendAddObjectMessage(e,o,'PipelineLayout',this._stringifyDescriptor(s[0]),n)}else if('createRenderPipeline'===t){const e=r.__id;s[0].__replacement||(this._sendAddObjectMessage(e,o,'RenderPipeline',this._stringifyDescriptor(s[0]),n),s[0].vertex?.module&&(r.__vertexModule=s[0].vertex?.module),s[0].fragment?.module&&(r.__fragmentModule=s[0].fragment?.module))}else if('createComputePipeline'===t){const e=r.__id;s[0].__replacement||(this._sendAddObjectMessage(e,o,'ComputePipeline',this._stringifyDescriptor(s[0]),n),s[0].compute?.module&&(r.__computeModule=s[0].compute?.module))}else if('createCommandEncoder'===t)r.__device=e;else if(r instanceof GPURenderBundle){const t=r.__id,s=e.__descriptor;s.commands=r._commands,this._sendAddObjectMessage(t,o,'RenderBundle',this._stringifyDescriptor(s),n),delete s.commands}this._captureFrameRequest&&this._captureCommand(e,t,s,n,r)}_captureCommand(e,t,r,s,n){const o=this._captureFrameCommands.length,i=r;1===i.length&&void 0===i[0]&&(i.length=0),('beginRenderPass'===t||'beginComputePass'===t||'createCommandEncoder'===t||'createRenderPassEncoder'===t||'finish'===t&&e instanceof GPUCommandEncoder)&&(n.__id=`_${o}`);let a=null;if('setBindGroup'===t){a=[];const t=i[0],r=i[1];if(a.push(t),a.push(r),i.length>2&&i[2]?.length){const e=i[2];if(e.length>0)if(e instanceof Uint32Array){const t=i[3],r=i[4];if(r>0){const s=new Uint32Array(e.buffer,4*t,r);a.push(s)}}else a.push(e)}const s=a.length>2?a[2]:null;let n=0;const c=r?.__descriptor,d=c?.layout?.__descriptor,p=d?.entries,l=new Map;if(s&&p){let e=0;for(let t=0;t<p.length;t++)if(p[t].buffer?.hasDynamicOffset){const r=p[t].binding;l.set(parseInt(r),s[e++])}}const h=Array.from(l.entries()).sort(((e,t)=>e[0]-t[0])),_=new Uint32Array(h.length);for(let e=0;e<h.length;e++)_[e]=h[e][1];if(n=0,c)for(const t in c.entries){const r=c.entries[t],i=p?p[t]:void 0,a=r?.resource?.buffer,d=i?.buffer?.hasDynamicOffset??!1;if(a){let i=r.resource.offset??0;const c=u(r.resource.size??a.size-i,4);(this._captureMaxBufferSize<0||c<=this._captureMaxBufferSize)&&(d&&null!==s&&(i=_[n++]),e.__captureBuffers||(e.__captureBuffers=[]),e.__captureBuffers.push({commandId:o,entryIndex:t,buffer:a,offset:i,size:c}),this._captureBuffersCount++,this._updateStatusMessage())}else r?.resource instanceof GPUTextureView&&(e.__captureTextureViews||(e.__captureTextureViews=new Set),e.__captureTextureViews.add(r.resource),this._updateStatusMessage())}}else if('writeBuffer'===t){a=[];const e=i[0],t=i[1];a.push(e),a.push(t);let r=i[2];if(i.length>3){const e=i[3]??0,t=i[4],s=r instanceof ArrayBuffer?r:r.buffer;s&&(t>0?r=new Uint8Array(s,e,t):e>0&&(r=new Uint8Array(s,e)))}a.push(r)}else a=i;if(a=this._processCommandArgs(a),this._captureFrameCommands.push({class:e.constructor.name,object:e.__id,result:n?.__id??0,commandId:o,method:t,args:a,stacktrace:s}),'setIndexBuffer'===t&&(e.__indexBuffer=r),'setVertexBuffer'===t){const t=r[0],s=r[1],n=r[2]??0,i=r[3]??s.size-n;e.__captureBuffers||(e.__captureBuffers=[]),e.__captureBuffers.push({commandId:o,entryIndex:t,buffer:s,offset:n,size:i}),this._captureBuffersCount++,this._updateStatusMessage()}if('setIndexBuffer'===t){const t=r[0],s=t.size;e.__captureBuffers||(e.__captureBuffers=[]),e.__captureBuffers.push({commandId:o,entryIndex:0,buffer:t,offset:0,size:s}),this._captureBuffersCount++,this._updateStatusMessage()}if('drawIndirect'===t||'drawIndexedIndirect'===t||'dispatchWorkgroupsIndirect'===t){const t=r[0],s=0,n=t.size;e.__captureBuffers||(e.__captureBuffers=[]),e.__captureBuffers.push({commandId:o,entryIndex:0,buffer:t,offset:s,size:n}),this._captureBuffersCount++,this._updateStatusMessage()}if('beginRenderPass'===t){if(r[0]?.colorAttachments?.length>0){n.__captureRenderPassTextures=new Set;for(const e of r[0].colorAttachments){if(!e)continue;const t=e.resolveTarget??e.view;n.__captureRenderPassTextures.add(t)}}if(n.__descriptor=r[0],r[0]?.depthStencilAttachment){n.__captureRenderPassTextures||(n.__captureRenderPassTextures=new Set);const e=r[0].depthStencilAttachment,t=e.resolveTarget??e.view;n.__captureRenderPassTextures.add(t)}this._inComputePass=!1,n.__commandEncoder=e}else if('beginComputePass'===t)n.__commandEncoder=e,this._inComputePass=!0;else if('end'===t){this._inComputePass=!1;const t=e.__commandEncoder;if(e.__captureBuffers?.length>0&&(this._recordCaptureBuffers(t,e.__captureBuffers),this._updateStatusMessage()),e.__captureRenderPassTextures?.size>0){let r=10*this._frameRenderPassCount;for(const s of e.__captureRenderPassTextures){const e=s.__texture;e&&this._captureTextureBuffer(t?.__device,t,e,r++)}e.__captureRenderPassTextures.clear()}if(e.__captureTextureViews?.size>0){for(const r of e.__captureTextureViews){const e=r.__texture;if(e){const s=r.mipLevelCount??e.mipLevelCount??1;for(let n=r.baseMipLevel??0;n<s;++n){this._captureTextureBuffer(t?.__device,t,e,-1,n);break}}}e.__captureTextureViews.clear()}e.__commandEncoder=null,e instanceof GPURenderPassEncoder&&this._frameRenderPassCount++}}_pendingMapFinished(){this._pendingMapCount--,0===this._pendingMapCount&&this._hasPendingDeviceDestroy&&(this._hasPendingDeviceDestroy=!1,this._detroyDevice())}_sendCaptureTextureBuffers(e){const t=[];for(const r of e)t.push(r.id);let r=0;for(const t of e){const e=t.tempBuffer.size;r+=Math.ceil(e/m)}this._postMessage({action:d.CaptureTextureFrames,chunkCount:r,count:e.length,textures:t});for(const t of e){const{id:e,tempBuffer:r,passId:s,mipLevel:n}=t;this._mappedTextureBufferCount++;const o=this;r.mapAsync(GPUMapMode.READ).then((()=>{o._mappedTextureBufferCount--,o._updateStatusMessage();const t=r.getMappedRange(),i=new Uint8Array(t);o._sendTextureData(e,s,i,n),r.destroy(),o._pendingMapFinished()})).catch((e=>{console.error(e)}))}this._updateStatusMessage()}_sendTextureData(e,r,s,n){const o=s.length,i=Math.ceil(o/m),a=this;for(let c=0;c<i;++c){const p=c*m,u=Math.min(m,o-p),l=s.slice(p,p+u);this._encodingTextureChunkCount++,this._updateStatusMessage(),t(l).then((t=>{a._postMessage({action:d.CaptureTextureData,id:e,passId:r,mipLevel:n,offset:p,size:o,index:c,count:i,chunk:t}),a._encodingTextureChunkCount--,a._updateStatusMessage()})).catch((e=>{console.log('Error encoding texture data:',e)}))}}_getTextureUtils(e){return e?(e.__textureUtils||(e.__textureUtils=new c(e)),e.__textureUtils):null}_sendBufferData(e,r,s){const n=s.length,o=Math.ceil(n/m),i=this;for(let a=0;a<o;++a){const c=a*m,p=Math.min(m,n-c),u=s.slice(c,c+p);this._encodingBufferChunkCount++,this._updateStatusMessage(),t(u).then((t=>{i._postMessage({action:d.CaptureBufferData,commandId:e,entryIndex:r,offset:c,size:n,index:a,count:o,chunk:t}),i._encodingBufferChunkCount--,i._updateStatusMessage()})).catch((e=>{console.error(e.message)}))}}_sendTimestampBuffer(e,t){const r=this;this._pendingMapCount++,t.mapAsync(GPUMapMode.READ).then((()=>{const e=t.getMappedRange(),s=new Uint8Array(e);r._sendBufferData(-1e3,-1e3,s),t.destroy(),r._pendingMapFinished()})).catch((e=>{console.error(e)}))}_sendCapturedBuffers(e){if(e.length>0){let t=0;for(const r of e){const e=r.tempBuffer.size;t+=Math.ceil(e/m)}this._postMessage({action:d.CaptureBuffers,count:e.length,chunkCount:t})}for(const t of e){const e=t.tempBuffer,r=t.commandId,s=t.entryIndex,n=this;this._mappedBufferCount++,this._updateStatusMessage(),e.mapAsync(GPUMapMode.READ).then((()=>{n._mappedBufferCount--,n._updateStatusMessage();const t=e.getMappedRange(),o=new Uint8Array(t);n._sendBufferData(r,s,o),e.destroy(),n._pendingMapFinished()})).catch((e=>{console.error(e)}))}}_recordCaptureBuffers(e,t){const r=e?.__device;if(!r)return this._captureBuffersCount-=t.length,void(t.length=0);for(const s of t){const{commandId:t,entryIndex:n,buffer:o,offset:i,size:a}=s;if(o.__destroyed)continue;let c=null;this.disableRecording();try{c=r.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,label:`BUFFER CAPTURE TEMP [${t},${n}]`}),e.copyBufferToBuffer(o,i,c,0,a),this._captureTempBuffers.push({commandId:t,entryIndex:n,tempBuffer:c})}catch(e){console.log(e)}this.enableRecording()}this._captureBuffersCount-=t.length,t.length=0}_captureTextureBuffer(e,t,r,s,n){if(!e)return;const o=!t;t??=e.createCommandEncoder(),n??=0,s??=-1,n=Math.max(Math.min(n,(r?.mipLevelCount??1)-1),0);const i=r.__id;let c=r.format,d=c?a[c]:void 0;if(!d)return;for(const e of this._captureTexturedBuffers)if(e.id===i&&e.passId===s&&e.mipLevel===n)return;if(d.isDepthStencil){this.disableRecording();try{r=this._getTextureUtils(e).copyDepthTexture(r,'r32float',t)}catch(e){return this.enableRecording(),void console.log(e)}this.enableRecording(),c=r.format,d=c?a[c]:void 0,r.__id=i,this._toDestroy.push(r)}else if(r.sampleCount>1){this.disableRecording();try{(r=this._getTextureUtils(e).copyMultisampledTexture(r)).__id=i,this._toDestroy.push(r)}catch(e){return this.enableRecording(),void console.log(e)}this.enableRecording()}const p=r.width>>n||1,u=r.height>>n||1,l=r.depthOrArrayLayers||1,h=p*d.bytesPerBlock+255&-256,_=h*u*l;if(!_||p<d.blockWidth||u<d.blockHeight)return;const f={width:p,height:u,depthOrArrayLayers:l};let m=null;try{this.disableRecording(),m=e.createBuffer({size:_,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});const s='all';t.copyTextureToBuffer({texture:r,aspect:s,mipLevel:n},{buffer:m,bytesPerRow:h,rowsPerImage:u},f)}catch(e){console.log(e)}o&&e.queue.submit([t.finish()]),this.enableRecording(),m&&(this._captureTexturedBuffers.push({id:i,tempBuffer:m,width:p,height:u,depthOrArrayLayers:l,format:c,passId:s,mipLevel:n}),this._updateStatusMessage())}_addCommandData(e){if(this._captureFrameRequest){const t=this._frameData.length;return this._frameData.push(e),t}return-1}_isHTMLImageElement(e){return!!s&&(e instanceof HTMLImageElement||e instanceof HTMLCanvasElement||e instanceof HTMLVideoElement)}_processCommandArgs(e){if(!e||e.constructor===Number||e.constructor===String||e.constructor===Boolean)return e;if(void 0!==e.__id)return{__id:e.__id,__class:e.constructor.name};if(e instanceof ImageBitmap||e instanceof ImageData||e instanceof OffscreenCanvas||e instanceof VideoFrame||this._isHTMLImageElement(e))return`@-1 ${e.constructor.name} ${e.width} ${e.height}`;if(e instanceof Array||void 0!==e.buffer){const t=100;if(e.length>t)return`@${this._addCommandData(e)} ${e.constructor.name} ${e.byteLength}`;const r=[];for(const t in e)r[t]=this._processCommandArgs(e[t]);return r}if(e instanceof ArrayBuffer)return`@${this._addCommandData(e)} ${e.constructor.name} ${e.byteLength}`;if(e instanceof Object){const t={};for(const r in e)t[r]=this._processCommandArgs(e[r]);return t}return e}};let g='<%=_webgpuHostAddress%>';const b=URL;function y(e){if(g.startsWith('<%='))return e;if(e?.constructor===String){if(e.startsWith('http://')||e.startsWith('https://')||e.startsWith('ws://')||e.startsWith('wss://')||e.startsWith('blob:')||e.startsWith('data:'))return e;try{if(new b(e).protocol)return e}catch(e){}return e.startsWith('/')?`${g}/${e}`:`<%=_webgpuBaseAddress%>/${e}`}return e}const P=self.fetch;if(self.fetch=(e,t)=>{let r=e instanceof Request?e.url:e;return r=y(r),P(r,t)},self.importScripts){const e=self.importScripts;self.importScripts=function(){const t=[...arguments];for(let e=0;e<t.length;++e)t[e]=y(t[e]);return e(...t)}}URL=new Proxy(URL,{construct:(e,t,r)=>(t.length>0&&(t[0]=y(t[0])),new e(...t))}),WebSocket=new Proxy(WebSocket,{construct:(e,t,r)=>(t.length>0&&(t[0]=y(t[0])),new e(...t))}),Request=new Proxy(Request,{construct:(e,t,r)=>(t.length>0&&(t[0]=y(t[0])),new e(...t))}),Worker=new Proxy(Worker,{construct(e,t,r){let s=`self.__webgpu_src = ${self.__webgpu_src.toString()};self.__webgpu_src();`,n=t[0],o=null;try{o=new b(n)}catch{const e=new b(document.currentScript&&'SCRIPT'===document.currentScript.tagName.toUpperCase()&&document.currentScript.src||new URL('webgpu_inspector.js',document.baseURI).href),t=n.startsWith('/')?'':'/';o=new URL(`${e.protocol}//${e.host}${t}${n}`)}const i=`${o.protocol}//${o.host}`,a=`${i}${o.pathname.substring(0,o.pathname.lastIndexOf('/'))}`;s=s.replaceAll('<%=_webgpuHostAddress%>',`${i}`),s=s.replaceAll('<%=_webgpuBaseAddress%>',`${a}`),t.length>1&&'module'===t[1]?.type?s+=`import ${JSON.stringify(o.href)};`:s+=`importScripts(${JSON.stringify(o.href)});`;let c=new Blob([s]);c=c.slice(0,c.size,'text/javascript'),t[0]=URL.createObjectURL(c);const d=new e(...t);return d.__webgpuInspector=!0,window.addEventListener('__WebGPUInspector',(e=>{d.__webgpuInspector&&e.detail.__webgpuInspector&&!e.detail.__webgpuInspectorPage&&d.postMessage({__WebGPUInspector:e.detail})})),d.addEventListener('message',(e=>{let t=e.data;t.__WebGPUInspector&&(t=t.__WebGPUInspector),t.__webgpuInspector&&window.dispatchEvent(new CustomEvent('__WebGPUInspector',{detail:t}))})),new Proxy(d,{get:(e,t,r)=>'addEventListener'===t?function(){if('message'===arguments[0]){const e=arguments[1];arguments[1]=function(){arguments[0].data.__webgpuInspector||arguments[0].data.__WebGPUInspector||e(...arguments)}}return e.addEventListener(...arguments)}:'terminate'===t?function(){const t=e.terminate(...arguments);return e.__webgpuInspector=!1,t}:t in e?'function'==typeof e[t]?e[t].bind(e):e[t]:void 0,set:(e,t,r,s)=>(e[t]=r,!0)})}})})(),Object.defineProperty(e,'__esModule',{value:!0})}({})}const t='WEBGPU_INSPECTOR_LOADED',r=sessionStorage.getItem(t);r&&(sessionStorage.removeItem(t),'true'!==r&&sessionStorage.setItem('WEBGPU_INSPECTOR_CAPTURE_FRAME',r),self.__webgpu_src=e,self.__webgpu_src()),window&&window.addEventListener('__WebGPUInspector',(t=>{const r=t.detail||t.data;'object'==typeof r&&r.__webgpuInspector&&'webgpu_inspector_start_inspection'===r.action&&(self.__webgpu_src||(self.__webgpu_src=e,self.__webgpu_src()))}))}();
//# sourceMappingURL=webgpu_inspector_loader.js.map
