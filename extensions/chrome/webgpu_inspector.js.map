{"version":3,"file":"webgpu_inspector.js","sources":["../../src/utils/base64.js","../../src/utils/signal.js","../../src/utils/stacktrace.js","../../src/utils/gpu_object_wrapper.js","../../src/utils/texture_format_info.js","../../src/utils/texture_utils.js","../../src/utils/actions.js","../../src/webgpu_inspector.js"],"sourcesContent":["export async function encodeDataUrl(bytes, type = \"application/octet-stream\") {\n  return await new Promise((resolve, reject) => {\n    const reader = Object.assign(new FileReader(), {\n      onload: () => resolve(reader.result),\n      onerror: () => reject(reader.error),\n    });\n    reader.readAsDataURL(new File([bytes], \"\", { type }));\n  });\n}\n\nexport async function decodeDataUrl(dataUrl) {\n  const res = await fetch(dataUrl);\n  return new Uint8Array(await res.arrayBuffer());\n}\n\n","/**\r\n * A Signal is like a proxy function that can have multiple \"listeners\" assigned to it, such that\r\n * when the Signal is executed (or \"emitted\"), it executes each of its associated listeners.\r\n * A listener is a callback function, object method, or another Signal.\r\n */\r\nexport class Signal {\r\n  /**\r\n   * @param {String} [name=\"\"] Optional name for the signal, usually used for debugging purposes.\r\n   */\r\n  constructor(name) {\r\n    this._lastSlotId = 0;\r\n    this.slots = new Map();\r\n    if (name) {\r\n      this.name = name;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @property {bool} enabled Returns true if signals are allowed to be emitted. If false,\r\n   * calling the Signal's emit method will do nothing.\r\n   */\r\n  static get enabled() {\r\n    return Signal._disableSignals == 0;\r\n  }\r\n\r\n  /***\r\n   * @property {bool} disabled Returns true if signals are disabled from being emitted. If true,\r\n   * calling the Signal's emit method will do nothing.\r\n   */\r\n  static get disabled() {\r\n    return Signal._disableSignals > 0;\r\n  }\r\n\r\n  /**\r\n   * Disables all signals from being emitted. This can be called multiple times, but an equal\r\n   * number of calls to enable should be used to re-enable signals. This is often used to disable\r\n   * any callbacks while doing heavy operations, like file loading, so a single signal will be\r\n   * emitted at the end.\r\n   */\r\n  static disable() {\r\n    return Signal._disableSignals++;\r\n  }\r\n\r\n  /**\r\n   * Enable signals to be emitted, having been previously disabled.\r\n   * @param {bool} [force=false] If true, signals will be forced to the enabled state,\r\n   * even if there were an unbalanced number of calls to disable..\r\n   */\r\n  static enable(force) {\r\n    if (force) {\r\n      Signal._disableSignals = 0;\r\n      return 0;\r\n    }\r\n    return Signal._disableSignals > 0 ? Signal._disableSignals-- : 0;\r\n  }\r\n\r\n  /**\r\n   * Disconnect the listener from all signals of the given object.\r\n   * @param {Object} object The object to disconnect from.\r\n   * @param {Function|Signal|Object} callback The listener to disconnect\r\n   * @param {Object?} [instance=null] The optional listener instance that owns callback.\r\n   */\r\n  static disconnect(object, callback, instance) {\r\n    for (const i in object) {\r\n      const p = object[i];\r\n      if (p.constructor === Signal) {\r\n        p.disconnect(callback, instance);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return all signals that belong to the object.\r\n   * @param {Object} object The object to get the signals from.\r\n   * @param {Array?} out Optional storage for the results. A new array will be created if null.\r\n   * @return {Array} The list of signals that belong to the object.\r\n   */\r\n  static getSignals(object, out) {\r\n    out = out || [];\r\n    for (const i in object) {\r\n      const p = object[i];\r\n      if (p.constructor === Signal) {\r\n        out.push(p);\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * @property {bool} hasListeners True if this signal has at least one listener.\r\n   */\r\n  get hasListeners() {\r\n    return this.slots.size > 0;\r\n  }\r\n\r\n  /**\r\n   * Emit a signal, calling all listeners.\r\n   * @param {...*} arguments Optional arguments to call the listeners with.\r\n   */\r\n  emit() {\r\n    if (Signal.disabled) {\r\n      return;\r\n    }\r\n\r\n    for (const k of this.slots) {\r\n      const s = k[1][0];\r\n      const o = k[1][1] || s;\r\n      if (!s) {\r\n        continue;\r\n      }\r\n\r\n      if (s.constructor === Signal) {\r\n        s.emit.apply(o, arguments);\r\n      } else {\r\n        s.apply(o, arguments);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connect a listener to the signal. This can be a function, object method,\r\n   * class static method, or another signal. There is no type-checking to\r\n   * ensure the listener function can successfully receive the arguments that\r\n   * will be emitted by the signal, which will result in an exception of you\r\n   * connect an incompatible listener and emit the signal.\r\n   * To have an object method listen to a signal, pass in the object, too.\r\n   * @param {Function|Signal} callback\r\n   * @param {Object?} [object=null]\r\n   * @example\r\n   * listen(Function)\r\n   * listen(Signal)\r\n   * listen(method, object)\r\n   */\r\n  addListener(callback, object) {\r\n    // Don't add the same listener multiple times.\r\n    if (this.isListening(callback, object)) {\r\n      return null;\r\n    }\r\n\r\n    this.slots.set(this._lastSlotId++, [callback, object]);\r\n    return this._lastSlotId - 1;\r\n  }\r\n\r\n  /**\r\n   * Checks if there is a binded listener that matches the criteria.\r\n   * @param {Function|Signal|Object} callback\r\n   * @param {Object?} [object=null]\r\n   * @return {bool}\r\n   * @example\r\n   * isListening(Signal)\r\n   * isListening(callback)\r\n   * isListening(object)\r\n   * isListening(method, object)\r\n   */\r\n  isListening(callback, object) {\r\n    for (const slot of this.slots) {\r\n      const slotInfo = slot[1];\r\n\r\n      if (callback && !object) {\r\n        if (slotInfo[0] === callback || slotInfo[1] === callback) {\r\n          return true;\r\n        }\r\n      } else if (!callback && object) {\r\n        if (slotInfo[1] === object) {\r\n          return true;\r\n        }\r\n      } else {\r\n        if (slotInfo[0] === callback && slotInfo[1] === object) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Disconnect a listener from the signal.\r\n   * @param {*} callback\r\n   * @param {Object?} object\r\n   * @example\r\n   * disconnect(Object) -- Disconnect all method listeners of the given object.\r\n   * disconnect(Function) -- Disconnect the function listener.\r\n   * disconnect(Signal) -- Disconnect the signal listener.\r\n   * disconnect(method, object) -- Disconnect the method listener.\r\n   * disconnect() -- Disconnect all listeners from the signal.\r\n   */\r\n  disconnect(callback, object) {\r\n    if (\r\n      (callback === null || callback === undefined) &&\r\n      (object === null || object === undefined)\r\n    ) {\r\n      this.slots.clear();\r\n      return true;\r\n    }\r\n\r\n    if (callback.constructor === Number) {\r\n      const handle = callback;\r\n      if (!this.slots.has(handle)) {\r\n        return false;\r\n      }\r\n      this.slots.delete(handle);\r\n      return true;\r\n    }\r\n\r\n    let found = false;\r\n    for (const slot of this.slots) {\r\n      const slotHandle = slot[0];\r\n      const slotInfo = slot[1];\r\n\r\n      if (callback && !object) {\r\n        if (slotInfo[0] === callback || slotInfo[1] === callback) {\r\n          this.slots.delete(slotHandle);\r\n          found = true;\r\n        }\r\n      } else if (!callback && object) {\r\n        if (slotInfo[1] === object) {\r\n          this.slots.delete(slotHandle);\r\n          found = true;\r\n        }\r\n      } else {\r\n        if (slotInfo[0] === callback && slotInfo[1] === object) {\r\n          this.slots.delete(slotHandle);\r\n          found = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return found;\r\n  }\r\n}\r\n\r\nSignal._disableSignals = 0;\r\n","export function getStacktrace() {\n  if (!Error.captureStackTrace) {\n    return \"\";\n  }\n  const stacktrace = {};\n  Error.captureStackTrace(stacktrace, getStacktrace);\n  if (!stacktrace.stack) {\n    return \"\";\n  }\n  let stack = stacktrace.stack\n    .split(\"\\n\")\n    .map((line) => line.split(\"at \")[1])\n    .slice(2) // Skip the Error line and the GPU.* line.\n    .filter((line) => line && !line.includes(\"webgpu_inspector.js\"));\n\n  return stack.join(\"\\n\");\n}\n\n// Cache stacktraces since many objects will have the same stacktrace.\n// Used as a singleton.\nexport class StacktraceCache {\n  constructor() {\n    this._cache = [];\n  }\n\n  _getStacktrace(id) {\n    return id < 0 ? \"\" : this._cache[id] ?? \"\";\n  }\n\n  _setStacktrace(stacktrace) {\n    if (!stacktrace) {\n      return -1;\n    }\n    const id = this._cache.indexOf(stacktrace);\n    if (id !== -1) {\n      return id;\n    }\n    this._cache.push(stacktrace);\n    return this._cache.length - 1;\n  }\n\n  static getStacktrace(id) {\n    return StacktraceCache._global._getStacktrace(id);\n  }\n\n  static setStacktrace(stacktrace) {\n    return StacktraceCache._global._setStacktrace(stacktrace);\n  }\n}\n\nStacktraceCache._global = new StacktraceCache();\n","import { Signal } from \"./signal.js\";\r\nimport { getStacktrace } from \"./stacktrace.js\";\r\n\r\nexport const GPUObjectTypes = new Set([\r\n  GPUAdapter,\r\n  GPUDevice,\r\n  GPUBuffer,\r\n  GPUTexture,\r\n  GPUTextureView,\r\n  //GPUExternalTexture,\r\n  GPUSampler,\r\n  GPUBindGroupLayout,\r\n  GPUBindGroup,\r\n  GPUPipelineLayout,\r\n  GPUShaderModule,\r\n  GPUComputePipeline,\r\n  GPURenderPipeline,\r\n  GPUCommandBuffer,\r\n  GPUCommandEncoder,\r\n  GPUComputePassEncoder,\r\n  GPURenderPassEncoder,\r\n  GPURenderBundle,\r\n  GPUQueue,\r\n  GPUQuerySet,\r\n  GPUCanvasContext\r\n]);\r\n\r\nexport const GPUCreateMethods = new Set([\r\n  \"createBuffer\",\r\n  \"createTexture\",\r\n  \"createSampler\",\r\n  \"importExternalTexture\",\r\n  \"createBindGroupLayout\",\r\n  \"createPipelineLayout\",\r\n  \"createBindGroup\",\r\n  \"createShaderModule\",\r\n  \"createComputePipeline\",\r\n  \"createRenderPipeline\",\r\n  \"createComputePipelineAsync\",\r\n  \"createRenderPipelineAsync\",\r\n  \"createCommandEncoder\",\r\n  \"createRenderBundleEncoder\",\r\n  \"createQuerySet\",\r\n  \"createView\"\r\n]);\r\n\r\nexport class GPUObjectWrapper {\r\n  constructor(idGenerator) {\r\n    this._idGenerator = idGenerator;\r\n    this.onPreCall = new Signal();\r\n    this.onPostCall = new Signal();\r\n    this.onPromise = new Signal();\r\n    this.onPromiseResolve = new Signal();\r\n    this.recordStacktraces = false;\r\n    this._wrapGPUTypes();\r\n  }\r\n\r\n  _wrapGPUTypes() {\r\n    GPU.prototype.requestAdapter = this._wrapMethod(\"requestAdapter\", GPU.prototype.requestAdapter);\r\n    GPU.prototype.getPreferredFormat = this._wrapMethod(\"getPreferredFormat\", GPU.prototype.getPreferredFormat);\r\n\r\n    GPUAdapter.prototype.requestDevice = this._wrapMethod(\"requestDevice\", GPUAdapter.prototype.requestDevice);\r\n\r\n    GPUDevice.prototype.destroy = this._wrapMethod(\"destroy\", GPUDevice.prototype.destroy);\r\n    GPUDevice.prototype.createBuffer = this._wrapMethod(\"createBuffer\", GPUDevice.prototype.createBuffer);\r\n    GPUDevice.prototype.createTexture = this._wrapMethod(\"createTexture\", GPUDevice.prototype.createTexture);\r\n    GPUDevice.prototype.createSampler = this._wrapMethod(\"createSampler\", GPUDevice.prototype.createSampler);\r\n    GPUDevice.prototype.importExternalTexture = this._wrapMethod(\"importExternalTexture\", GPUDevice.prototype.importExternalTexture);\r\n    GPUDevice.prototype.createBindGroupLayout = this._wrapMethod(\"createBindGroupLayout\", GPUDevice.prototype.createBindGroupLayout);\r\n    GPUDevice.prototype.createPipelineLayout = this._wrapMethod(\"createPipelineLayout\", GPUDevice.prototype.createPipelineLayout);\r\n    GPUDevice.prototype.createBindGroup = this._wrapMethod(\"createBindGroup\", GPUDevice.prototype.createBindGroup);\r\n    GPUDevice.prototype.createShaderModule = this._wrapMethod(\"createShaderModule\", GPUDevice.prototype.createShaderModule);\r\n    GPUDevice.prototype.createComputePipeline = this._wrapMethod(\"createComputePipeline\", GPUDevice.prototype.createComputePipeline);\r\n    GPUDevice.prototype.createRenderPipeline = this._wrapMethod(\"createRenderPipeline\", GPUDevice.prototype.createRenderPipeline);\r\n    GPUDevice.prototype.createComputePipelineAsync = this._wrapMethod(\"createComputePipelineAsync\", GPUDevice.prototype.createComputePipelineAsync);\r\n    GPUDevice.prototype.createRenderPipelineAsync = this._wrapMethod(\"createRenderPipelineAsync\", GPUDevice.prototype.createRenderPipelineAsync);\r\n    GPUDevice.prototype.createCommandEncoder = this._wrapMethod(\"createCommandEncoder\", GPUDevice.prototype.createCommandEncoder);\r\n    GPUDevice.prototype.createRenderBundleEncoder = this._wrapMethod(\"createRenderBundleEncoder\", GPUDevice.prototype.createRenderBundleEncoder);\r\n    GPUDevice.prototype.createQuerySet = this._wrapMethod(\"createQuerySet\", GPUDevice.prototype.createQuerySet);\r\n\r\n    GPUBuffer.prototype.mapAsync = this._wrapMethod(\"mapAsync\", GPUBuffer.prototype.mapAsync);\r\n    GPUBuffer.prototype.getMappedRange = this._wrapMethod(\"getMappedRange\", GPUBuffer.prototype.getMappedRange);\r\n    GPUBuffer.prototype.unmap = this._wrapMethod(\"unmap\", GPUBuffer.prototype.unmap);\r\n    GPUBuffer.prototype.destroy = this._wrapMethod(\"destroy\", GPUBuffer.prototype.destroy);\r\n\r\n    GPUTexture.prototype.createView = this._wrapMethod(\"createView\", GPUTexture.prototype.createView);\r\n    GPUTexture.prototype.destroy = this._wrapMethod(\"destroy\", GPUTexture.prototype.destroy);\r\n\r\n    GPUShaderModule.prototype.getCompilationInfo = this._wrapMethod(\"getCompilationInfo\", GPUShaderModule.prototype.getCompilationInfo);\r\n\r\n    GPUComputePipeline.prototype.getBindGroupLayout = this._wrapMethod(\"getBindGroupLayout\", GPUComputePipeline.prototype.getBindGroupLayout);\r\n\r\n    GPURenderPipeline.prototype.getBindGroupLayout = this._wrapMethod(\"getBindGroupLayout\", GPURenderPipeline.prototype.getBindGroupLayout);\r\n\r\n    GPUCommandEncoder.prototype.beginRenderPass = this._wrapMethod(\"beginRenderPass\", GPUCommandEncoder.prototype.beginRenderPass);\r\n    GPUCommandEncoder.prototype.beginComputePass = this._wrapMethod(\"beginComputePass\", GPUCommandEncoder.prototype.beginComputePass);\r\n    GPUCommandEncoder.prototype.copyBufferToBuffer = this._wrapMethod(\"copyBufferToBuffer\", GPUCommandEncoder.prototype.copyBufferToBuffer);\r\n    GPUCommandEncoder.prototype.copyBufferToTexture = this._wrapMethod(\"copyBufferToTexture\", GPUCommandEncoder.prototype.copyBufferToTexture);\r\n    GPUCommandEncoder.prototype.copyTextureToBuffer = this._wrapMethod(\"copyTextureToBuffer\", GPUCommandEncoder.prototype.copyTextureToBuffer);\r\n    GPUCommandEncoder.prototype.copyTextureToTexture = this._wrapMethod(\"copyTextureToTexture\", GPUCommandEncoder.prototype.copyTextureToTexture);\r\n    GPUCommandEncoder.prototype.clearBuffer = this._wrapMethod(\"clearBuffer\", GPUCommandEncoder.prototype.clearBuffer);\r\n    GPUCommandEncoder.prototype.resolveQuerySet = this._wrapMethod(\"resolveQuerySet\", GPUCommandEncoder.prototype.resolveQuerySet);\r\n    GPUCommandEncoder.prototype.finish = this._wrapMethod(\"finish\", GPUCommandEncoder.prototype.finish);\r\n    GPUCommandEncoder.prototype.pushDebugGroup = this._wrapMethod(\"pushDebugGroup\", GPUCommandEncoder.prototype.pushDebugGroup);\r\n    GPUCommandEncoder.prototype.popDebugGroup = this._wrapMethod(\"popDebugGroup\", GPUCommandEncoder.prototype.popDebugGroup);\r\n    GPUCommandEncoder.prototype.insertDebugMarker = this._wrapMethod(\"insertDebugMarker\", GPUCommandEncoder.prototype.insertDebugMarker);\r\n\r\n    GPUComputePassEncoder.prototype.setPipeline = this._wrapMethod(\"setPipeline\", GPUComputePassEncoder.prototype.setPipeline);\r\n    GPUComputePassEncoder.prototype.dispatchWorkgroups = this._wrapMethod(\"dispatchWorkgroups\", GPUComputePassEncoder.prototype.dispatchWorkgroups);\r\n    GPUComputePassEncoder.prototype.dispatchWorkgroupsIndirect = this._wrapMethod(\"dispatchWorkgroupsIndirect\", GPUComputePassEncoder.prototype.dispatchWorkgroupsIndirect);\r\n    GPUComputePassEncoder.prototype.end = this._wrapMethod(\"end\", GPUComputePassEncoder.prototype.end);\r\n    GPUComputePassEncoder.prototype.setBindGroup = this._wrapMethod(\"setBindGroup\", GPUComputePassEncoder.prototype.setBindGroup);\r\n    GPUComputePassEncoder.prototype.setBindGroup = this._wrapMethod(\"setBindGroup\", GPUComputePassEncoder.prototype.setBindGroup);\r\n    GPUComputePassEncoder.prototype.pushDebugGroup = this._wrapMethod(\"pushDebugGroup\", GPUComputePassEncoder.prototype.pushDebugGroup);\r\n    GPUComputePassEncoder.prototype.popDebugGroup = this._wrapMethod(\"popDebugGroup\", GPUComputePassEncoder.prototype.popDebugGroup);\r\n    GPUComputePassEncoder.prototype.insertDebugMarker = this._wrapMethod(\"insertDebugMarker\", GPUComputePassEncoder.prototype.insertDebugMarker);\r\n\r\n    GPURenderPassEncoder.prototype.setViewport = this._wrapMethod(\"setViewport\", GPURenderPassEncoder.prototype.setViewport);\r\n    GPURenderPassEncoder.prototype.setScissorRect = this._wrapMethod(\"setScissorRect\", GPURenderPassEncoder.prototype.setScissorRect);\r\n    GPURenderPassEncoder.prototype.setBlendConstant = this._wrapMethod(\"setBlendConstant\", GPURenderPassEncoder.prototype.setBlendConstant);\r\n    GPURenderPassEncoder.prototype.setStencilReference = this._wrapMethod(\"setStencilReference\", GPURenderPassEncoder.prototype.setStencilReference);\r\n    GPURenderPassEncoder.prototype.beginOcclusionQuery = this._wrapMethod(\"beginOcclusionQuery\", GPURenderPassEncoder.prototype.beginOcclusionQuery);\r\n    GPURenderPassEncoder.prototype.endOcclusionQuery = this._wrapMethod(\"endOcclusionQuery\", GPURenderPassEncoder.prototype.endOcclusionQuery);\r\n    GPURenderPassEncoder.prototype.executeBundles = this._wrapMethod(\"executeBundles\", GPURenderPassEncoder.prototype.executeBundles);\r\n    GPURenderPassEncoder.prototype.end = this._wrapMethod(\"end\", GPURenderPassEncoder.prototype.end);\r\n    GPURenderPassEncoder.prototype.setPipeline = this._wrapMethod(\"setPipeline\", GPURenderPassEncoder.prototype.setPipeline);\r\n    GPURenderPassEncoder.prototype.setIndexBuffer = this._wrapMethod(\"setIndexBuffer\", GPURenderPassEncoder.prototype.setIndexBuffer);\r\n    GPURenderPassEncoder.prototype.setVertexBuffer = this._wrapMethod(\"setVertexBuffer\", GPURenderPassEncoder.prototype.setVertexBuffer);\r\n    GPURenderPassEncoder.prototype.draw = this._wrapMethod(\"draw\", GPURenderPassEncoder.prototype.draw);\r\n    GPURenderPassEncoder.prototype.drawIndexed = this._wrapMethod(\"drawIndexed\", GPURenderPassEncoder.prototype.drawIndexed);\r\n    GPURenderPassEncoder.prototype.drawIndirect = this._wrapMethod(\"drawIndirect\", GPURenderPassEncoder.prototype.drawIndirect);\r\n    GPURenderPassEncoder.prototype.drawIndexedIndirect = this._wrapMethod(\"drawIndexedIndirect\", GPURenderPassEncoder.prototype.drawIndexedIndirect);\r\n    GPURenderPassEncoder.prototype.setBindGroup = this._wrapMethod(\"setBindGroup\", GPURenderPassEncoder.prototype.setBindGroup);\r\n    GPURenderPassEncoder.prototype.pushDebugGroup = this._wrapMethod(\"pushDebugGroup\", GPURenderPassEncoder.prototype.pushDebugGroup);\r\n    GPURenderPassEncoder.prototype.popDebugGroup = this._wrapMethod(\"popDebugGroup\", GPURenderPassEncoder.prototype.popDebugGroup);\r\n    GPURenderPassEncoder.prototype.insertDebugMarker = this._wrapMethod(\"insertDebugMarker\", GPURenderPassEncoder.prototype.insertDebugMarker);\r\n\r\n    GPUQueue.prototype.submit = this._wrapMethod(\"submit\", GPUQueue.prototype.submit);\r\n    GPUQueue.prototype.writeBuffer = this._wrapMethod(\"writeBuffer\", GPUQueue.prototype.writeBuffer);\r\n    GPUQueue.prototype.writeTexture = this._wrapMethod(\"writeTexture\", GPUQueue.prototype.writeTexture);\r\n    GPUQueue.prototype.copyExternalImageToTexture = this._wrapMethod(\"copyExternalImageToTexture\", GPUQueue.prototype.copyExternalImageToTexture);\r\n\r\n    GPUQuerySet.prototype.destroy = this._wrapMethod(\"destroy\", GPUQuerySet.prototype.destroy);\r\n\r\n    GPUCanvasContext.prototype.configure = this._wrapMethod(\"configure\", GPUCanvasContext.prototype.configure);\r\n    GPUCanvasContext.prototype.unconfigure = this._wrapMethod(\"unconfigure\", GPUCanvasContext.prototype.unconfigure);\r\n    GPUCanvasContext.prototype.getCurrentTexture = this._wrapMethod(\"getCurrentTexture\", GPUCanvasContext.prototype.getCurrentTexture);\r\n  }\r\n\r\n  _wrapMethod(method, origMethod) {\r\n    const self = this;\r\n    return function () {\r\n      const object = this;\r\n\r\n      const args = [...arguments];\r\n\r\n      // Allow the arguments to be modified before the method is called.\r\n      self.onPreCall.emit(object, method, args);\r\n\r\n      // Call the original method\r\n      const result = origMethod.call(object, ...args);\r\n\r\n      const isCreate = GPUCreateMethods.has(method);\r\n\r\n      const stacktrace = self.recordStacktraces || isCreate ? getStacktrace() : undefined;\r\n\r\n      // If it was an async method it will have returned a Promise\r\n      if (result instanceof Promise) {\r\n        const id = self._idGenerator.getNextId(object);\r\n        self.onPromise.emit(object, method, args, id, stacktrace);\r\n        const promise = result;\r\n        const wrappedPromise = new Promise((resolve) => {\r\n          promise.then((result) => {\r\n            self.onPromiseResolve.emit(object, method, args, id, result, stacktrace);\r\n            resolve(result);\r\n          });\r\n        });\r\n        return wrappedPromise;\r\n      }\r\n\r\n      // Otherwise it's a synchronous method\r\n      self.onPostCall.emit(object, method, args, result, stacktrace);\r\n\r\n      return result;\r\n    };\r\n  }\r\n}\r\n","export const TextureFormatInfo = {\r\n    \"r8unorm\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"r8snorm\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"r8uint\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"r8sint\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg8unorm\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg8snorm\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg8uint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg8sint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba8unorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba8unorm-srgb\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba8snorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba8uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba8sint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"bgra8unorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"bgra8unorm-srgb\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"r16uint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"r16sint\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"r16float\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg16uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg16sint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg16float\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba16uint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba16sint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba16float\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"r32uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"r32sint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"r32float\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg32uint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg32sint\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg32float\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba32uint\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba32sint\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgba32float\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \r\n    \"rgb10a2uint\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rgb10a2unorm\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n    \"rg11b10ufloat\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n\r\n    // Depth Stencil Formats\r\n    \"stencil8\": { \"bytesPerBlock\": 1, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": false, \"hasStencil\": true }, // bytesPerBlock is actually 1-4\r\n    \"depth16unorm\": { \"bytesPerBlock\": 2, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": false },\r\n    \"depth24plus\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": false, \"depthOnlyFormat\": \"depth32float\" },\r\n    \"depth24plus-stencil8\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": true, \"depthOnlyFormat\": \"depth32float\" }, // bytesPerBlock is actually 4-8\r\n    \"depth32float\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": false },\r\n    \"depth32float-stencil8\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false, \"isDepthStencil\": true, \"hasDepth\": true, \"hasStencil\": true, \"stencilOnlyFormat\": \"depth32float\" }, // bytesPerBlock is actually 5-8\r\n\r\n    // Packed Formats\r\n    \"rgb9e5ufloat\": { \"bytesPerBlock\": 4, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": false },\r\n\r\n    // Compressed Formats\r\n    \"bc1-rgba-unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc1-rgba-unorm-srgb\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc2-rgba-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc2-rgba-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc3-rgba-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc3-rgba-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc4-r-unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc4-r-snorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc5-rg-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc5-rg-snorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc6h-rgb-ufloat\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc6h-rgb-float\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc7-rgba-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"bc7-rgba-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \r\n    \"etc2-rgb8unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"etc2-rgb8unorm-srgb\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"etc2-rgb8a1unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"etc2-rgb8a1unorm-srgb\": { \"bytesPerBlock\": 8, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"etc2-rgba8unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"etc2-rgba8unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \r\n    \"eac-r11unorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true },\r\n    \"eac-r11snorm\": { \"bytesPerBlock\": 8, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true },\r\n    \"eac-rg11unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true },\r\n    \"eac-rg11snorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 1, \"blockHeight\": 1, \"isCompressed\": true },\r\n\r\n    \"astc-4x4-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"astc-4x4-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 4, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"astc-5x4-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"astc-5x4-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 4, \"isCompressed\": true },\r\n    \"astc-5x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 5, \"isCompressed\": true },\r\n    \"astc-5x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 5, \"blockHeight\": 5, \"isCompressed\": true },\r\n    \"astc-6x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 5, \"isCompressed\": true },\r\n    \"astc-6x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 5, \"isCompressed\": true },\r\n    \"astc-6x6-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 6, \"isCompressed\": true },\r\n    \"astc-6x6-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 6, \"blockHeight\": 6, \"isCompressed\": true },\r\n    \"astc-8x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 5, \"isCompressed\": true },\r\n    \"astc-8x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 5, \"isCompressed\": true },\r\n    \"astc-8x6-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 6, \"isCompressed\": true },\r\n    \"astc-8x6-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 6, \"isCompressed\": true },\r\n    \"astc-8x8-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 8, \"isCompressed\": true },\r\n    \"astc-8x8-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 8, \"blockHeight\": 8, \"isCompressed\": true },\r\n    \"astc-10x5-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 5, \"isCompressed\": true },\r\n    \"astc-10x5-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 5, \"isCompressed\": true },\r\n    \"astc-10x6-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 6, \"isCompressed\": true },\r\n    \"astc-10x6-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 6, \"isCompressed\": true },\r\n    \"astc-10x8-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 8, \"isCompressed\": true },\r\n    \"astc-10x8-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 8, \"isCompressed\": true },\r\n    \"astc-10x10-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 10, \"isCompressed\": true },\r\n    \"astc-10x10-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 10, \"blockHeight\": 10, \"isCompressed\": true },\r\n    \"astc-12x10-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 10, \"isCompressed\": true },\r\n    \"astc-12x10-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 10, \"isCompressed\": true },\r\n    \"astc-12x12-unorm\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 12, \"isCompressed\": true },\r\n    \"astc-12x12-unorm-srgb\": { \"bytesPerBlock\": 16, \"blockWidth\": 12, \"blockHeight\": 12, \"isCompressed\": true },\r\n};\r\n","//import { TextureFormatInfo } from \"./texture_format_info.js\";\r\n\r\nexport class TextureUtils {\r\n  constructor(device) {\r\n    this.device = device;\r\n    this.blitShaderModule = device.createShaderModule({code: TextureUtils.blitShader});\r\n    this.blitDepthShaderModule = device.createShaderModule({code: TextureUtils.blitDepthShader});\r\n    this.blitPipelines = {};\r\n    this.blitDepthPipelines = {};\r\n    this.bindGroupLayouts = new Map();\r\n    this.pipelineLayouts = new Map();\r\n\r\n    this.pointSampler = device.createSampler({\r\n        magFilter: 'nearest',\r\n        minFilter: 'nearest',\r\n    });\r\n\r\n    this.displayUniformBuffer = device.createBuffer({\r\n      size: 4,\r\n      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\r\n    });\r\n\r\n    this.displayBingGroupLayout = device.createBindGroupLayout({\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          visibility: GPUShaderStage.FRAGMENT,\r\n          buffer: {\r\n            type: \"uniform\"\r\n          }\r\n        }\r\n      ]\r\n    });\r\n\r\n    this.displayBindGroup = device.createBindGroup({\r\n      layout: this.displayBingGroupLayout,\r\n      entries: [\r\n        {\r\n          binding: 0,\r\n          resource: { buffer: this.displayUniformBuffer }\r\n        }\r\n      ]\r\n    });\r\n  }\r\n\r\n  copyDepthTexture(src, format) {\r\n    const width = src.width;\r\n    const height = src.height;\r\n    const usage = src.usage | GPUTextureUsage.RENDER_TARGET | GPUTextureUsage.COPY_SRC;\r\n    const size = [width, height, 1]\r\n    const dst = this.device.createTexture({ format, size, usage });\r\n\r\n    let pipeline = this.blitDepthPipelines[format];\r\n    if (!pipeline) {\r\n      pipeline = this.device.createRenderPipeline({\r\n        layout: 'auto',\r\n        vertex: {\r\n          module: this.blitDepthShaderModule,\r\n          entryPoint: 'vertexMain',\r\n        },\r\n        fragment: {\r\n          module: this.blitDepthShaderModule,\r\n          entryPoint: 'fragmentMain',\r\n          targets: [],\r\n        },\r\n        depthStencil: {\r\n          format,\r\n          depthWriteEnabled: true,\r\n          depthCompare: \"always\"\r\n        },\r\n        primitive: {\r\n          topology: 'triangle-list',\r\n        },\r\n      });\r\n      this.blitDepthPipelines[format] = pipeline;\r\n    }\r\n\r\n    const srcView = src.createView({ aspect: \"depth-only\" });\r\n\r\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\r\n    const bindGroup = this.device.createBindGroup({\r\n      layout: bindGroupLayout,\r\n      entries: [\r\n        { binding: 0, resource: this.pointSampler },\r\n        { binding: 1, resource: srcView }\r\n      ],\r\n    });\r\n\r\n    const commandEncoder = this.device.createCommandEncoder();\r\n\r\n    const dstView = dst.createView();\r\n\r\n    const passDesc = {\r\n      colorAttachments: [],\r\n      depthStencilAttachment: {\r\n        view: dstView,\r\n        depthLoadOp: 'clear',\r\n        depthStoreOp: 'store',\r\n        depthClearValue: 0,\r\n        depthReadOnly: false\r\n      }\r\n    };\r\n\r\n    const passEncoder = commandEncoder.beginRenderPass(passDesc);\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.draw(3);\r\n    passEncoder.end();\r\n    this.device.queue.submit([commandEncoder.finish()]);\r\n    \r\n    return dst;\r\n  }\r\n\r\n  blitTexture(src, dst, dstFormat, display) {\r\n    const sampleType = \"unfilterable-float\";\r\n\r\n    if (!this.bindGroupLayouts.has(sampleType)) {\r\n      const bindGroupLayout = this.device.createBindGroupLayout({\r\n        entries: [\r\n          {\r\n            binding: 0,\r\n            visibility: GPUShaderStage.FRAGMENT,\r\n            sampler: {\r\n              type: \"non-filtering\"\r\n            }\r\n          },\r\n          {\r\n            binding: 1,\r\n            visibility: GPUShaderStage.FRAGMENT,\r\n            texture: {\r\n              sampleType: sampleType\r\n            }\r\n          }\r\n        ]\r\n      });\r\n      this.bindGroupLayouts.set(sampleType, bindGroupLayout);\r\n\r\n      const pipelineLayout = this.device.createPipelineLayout({\r\n        bindGroupLayouts: [bindGroupLayout, this.displayBingGroupLayout]\r\n      });\r\n      this.pipelineLayouts.set(sampleType, pipelineLayout);\r\n    }\r\n\r\n    const bindGroupLayout = this.bindGroupLayouts.get(sampleType);\r\n    const pipelineLayout = this.pipelineLayouts.get(sampleType);\r\n\r\n    const pipelineKey = `${dstFormat}#${sampleType}`;\r\n    let pipeline = this.blitPipelines[pipelineKey];\r\n    if (!pipeline) {\r\n      pipeline = this.device.createRenderPipeline({\r\n        layout: pipelineLayout,\r\n        vertex: {\r\n          module: this.blitShaderModule,\r\n          entryPoint: 'vertexMain',\r\n        },\r\n        fragment: {\r\n          module: this.blitShaderModule,\r\n          entryPoint: 'fragmentMain',\r\n          targets: [ { format: dstFormat } ],\r\n        },\r\n        primitive: {\r\n          topology: 'triangle-list',\r\n        },\r\n      });\r\n      this.blitPipelines[pipelineKey] = pipeline;\r\n    }\r\n\r\n    const bindGroup = this.device.createBindGroup({\r\n      layout: bindGroupLayout,\r\n      entries: [\r\n        { binding: 0, resource: this.pointSampler },\r\n        { binding: 1, resource: src }\r\n      ],\r\n    });\r\n    \r\n    const commandEncoder = this.device.createCommandEncoder();\r\n\r\n    const passDesc = {\r\n      colorAttachments: [{\r\n        view: dst,\r\n        loadOp: 'clear',\r\n        storeOp: 'store'\r\n      }]\r\n    };\r\n\r\n    if (display) {\r\n      this.device.queue.writeBuffer(this.displayUniformBuffer, 0,\r\n        new Float32Array([display.exposure]));\r\n    } else {\r\n      this.device.queue.writeBuffer(this.displayUniformBuffer, 0,\r\n        new Float32Array([1]));\r\n    }\r\n\r\n    const passEncoder = commandEncoder.beginRenderPass(passDesc);\r\n    passEncoder.setPipeline(pipeline);\r\n    passEncoder.setBindGroup(0, bindGroup);\r\n    passEncoder.setBindGroup(1, this.displayBindGroup);\r\n    passEncoder.draw(3);\r\n    passEncoder.end();\r\n\r\n    this.device.queue.submit([commandEncoder.finish()]);\r\n  }\r\n}\r\n\r\nTextureUtils.blitShader = `\r\n  var<private> posTex:array<vec4f, 3> = array<vec4f, 3>(\r\n    vec4f(-1.0, 1.0, 0.0, 0.0),\r\n    vec4f(3.0, 1.0, 2.0, 0.0),\r\n    vec4f(-1.0, -3.0, 0.0, 2.0));\r\n  struct VertexOutput {\r\n    @builtin(position) position: vec4f,\r\n    @location(0) uv: vec2f\r\n  };\r\n  @vertex\r\n  fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\r\n    var output: VertexOutput;\r\n    output.uv = posTex[vertexIndex].zw;\r\n    output.position = vec4f(posTex[vertexIndex].xy, 0.0, 1.0);\r\n    return output;;\r\n  }\r\n  @group(0) @binding(0) var texSampler: sampler;\r\n  @group(0) @binding(1) var texture: texture_2d<f32>;\r\n  struct Display {\r\n    exposure: f32,\r\n  };\r\n  @group(1) @binding(0) var<uniform> display: Display; \r\n  @fragment\r\n  fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\r\n    var color = textureSample(texture, texSampler, input.uv);\r\n    var rgb = color.rgb;\r\n    return vec4f(rgb * display.exposure, color.a);\r\n  }\r\n`;\r\n\r\nTextureUtils.blitDepthShader = `\r\n  var<private> posTex:array<vec4f, 3> = array<vec4f, 3>(\r\n    vec4f(-1.0, 1.0, 0.0, 0.0),\r\n    vec4f(3.0, 1.0, 2.0, 0.0),\r\n    vec4f(-1.0, -3.0, 0.0, 2.0));\r\n  struct VertexOutput {\r\n    @builtin(position) position: vec4f,\r\n    @location(0) uv: vec2f\r\n  };\r\n  @vertex\r\n  fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\r\n    var output: VertexOutput;\r\n    output.uv = posTex[vertexIndex].zw;\r\n    output.position = vec4f(posTex[vertexIndex].xy, 0.0, 1.0);\r\n    return output;;\r\n  }\r\n  @binding(0) @group(0) var texSampler: sampler;\r\n  @binding(1) @group(0) var texture: texture_depth_2d;\r\n  @fragment\r\n  fn fragmentMain(input: VertexOutput) -> @builtin(frag_depth) f32 {\r\n    return textureSample(texture, texSampler, input.uv);\r\n  }\r\n`;\r\n","export const Actions = {\r\n  CaptureBufferData: \"webgpu_inspect_capture_buffer_data\",\r\n  CaptureBuffers: \"webgpu_inspect_capture_buffers\",\r\n  DeleteObjects: \"webgpu_inspect_delete_objects\",\r\n  ValidationError: \"webgpu_inspect_validation_error\",\r\n  MemoryLeakWarning: \"webgpu_inspect_memory_leak_warning\",\r\n  DeltaTime: \"webgpu_inspect_delta_time\",\r\n  CaptureFrameResults: \"webgpu_inspect_capture_frame_results\",\r\n  CaptureFrameCommands: \"webgpu_inspect_capture_frame_commands\",\r\n  ObjectSetLabel: \"webgpu_inspect_object_set_label\",\r\n  AddObject: \"webgpu_inspect_add_object\",\r\n  ResolveAsyncObject: \"webgpu_inspect_resolve_async_object\",\r\n  DeleteObject: \"webgpu_inspect_delete_object\",\r\n  CaptureTextureFrames: \"webgpu_inspect_capture_texture_frames\",\r\n  CaptureTextureData: \"webgpu_inspect_capture_texture_data\",\r\n  CaptureBufferData: \"webgpu_inspect_capture_buffer_data\",\r\n\r\n  Recording: \"webgpu_record_recording\"\r\n};\r\n\r\nActions.values = new Set(Object.values(Actions));\r\n\r\nexport const PanelActions = {\r\n  RequestTexture: \"webgpu_inspect_request_texture\",\r\n  CompileShader: \"webgpu_inspect_compile_shader\",\r\n  Capture: \"webgpu_inspector_capture\",\r\n  InitializeInspector: \"webgpu_initialize_inspector\",\r\n  InitializeRecorder: \"webgpu_initialize_recorder\"\r\n};\r\n","import { encodeDataUrl } from \"./utils/base64.js\";\r\nimport { GPUObjectTypes, GPUObjectWrapper } from \"./utils/gpu_object_wrapper.js\";\r\nimport { TextureFormatInfo } from \"./utils/texture_format_info.js\";\r\nimport { TextureUtils } from \"./utils/texture_utils.js\";\r\nimport { Actions, PanelActions } from \"./utils/actions.js\";\r\n\r\n(() => {\r\n  const webgpuInspectorCaptureFrameKey = \"WEBGPU_INSPECTOR_CAPTURE_FRAME\";\r\n\r\n  // How much data should we send to the panel via message as a chunk.\r\n  // Messages can't send that much data .\r\n  const maxDataChunkSize = (1024 * 1024) / 4;\r\n  const maxBufferCaptureSize = (1024 * 1024) / 4;\r\n\r\n  class WebGPUInspector {\r\n    constructor() {\r\n      this._frameCommands = [];\r\n      this._frameData = [];\r\n      this._frameRenderPassCount = 0;\r\n      this._captureTextureViews = [];\r\n      this._lastCommandEncoder = null;\r\n      this._captureCommandEncoder = null;\r\n      this._captureTexturedBuffers = [];\r\n      this._currentFrame = null;\r\n      this._frameIndex = 0;\r\n      this._initalized = true;\r\n      this._objectID = 1;\r\n      this._lastFrameTime = 0;\r\n      this._frameCommandCount = 0;\r\n      this._captureRequest = false;\r\n      this._skipRecord = false;\r\n      this._errorChecking = true;\r\n      this._trackedObjects = new Map();\r\n      this._trackedObjectInfo = new Map();\r\n      this._bindGroupCount = 0;\r\n      this._captureTextureRequest = new Map();\r\n      this._toDestroy = [];\r\n      this._objectMap = new Map();\r\n      this._captureBuffers = [];\r\n      this._captureTempBuffers = [];\r\n      this._mappedTextureBufferCount = 0;\r\n      this._encodingTextureChunkCount = 0;\r\n      this._mappedBufferCount = 0;\r\n      this._encodingBufferChunkCount = 0;\r\n\r\n      if (!window.navigator.gpu) {\r\n        // No WebGPU support\r\n        return;\r\n      }\r\n\r\n      const statusContainer = document.createElement(\"div\");\r\n      statusContainer.style = \"position: absolute; z-index: 1000000; margin-left: 10px; margin-top: 5px;\";\r\n      document.body.insertBefore(statusContainer, document.body.firstChild);\r\n\r\n      this._inspectingStatus = document.createElement(\"div\");\r\n      this._inspectingStatus.title = \"WebGPU Inspector Running\";\r\n      this._inspectingStatus.style = \"height: 10px; width: 10px; display: inline-block; margin-right: 5px; background-color: #ff0; border-radius: 50%; border: 1px solid #000; box-shadow: inset -4px -4px 4px -3px rgb(255,100,0), 2px 2px 3px rgba(0,0,0,0.8);\";\r\n      statusContainer.appendChild(this._inspectingStatus);\r\n\r\n      this._inspectingStatusText = document.createElement(\"div\");\r\n      this._inspectingStatusText.style = \"display: inline-block; font-size: 12pt;color: #070; text-shadow: #fff 1px 1px 1px;\";\r\n      statusContainer.appendChild(this._inspectingStatusText);\r\n\r\n      this._gpuWrapper = new GPUObjectWrapper(this);\r\n\r\n      const self = this;\r\n      this._gpuWrapper.onPromiseResolve.addListener(this._onAsyncResolve, this);\r\n      this._gpuWrapper.onPreCall.addListener(this._preMethodCall, this);\r\n      this._gpuWrapper.onPostCall.addListener(this._onMethodCall, this);\r\n\r\n      this._garbageCollectectedObjects = [];\r\n     \r\n      // Track garbage collected WebGPU objects\r\n      this._garbageCollectionRegistry = new FinalizationRegistry((id) => {\r\n        if (id > 0) {\r\n          // It's too slow to send a message for every object that gets garbage collected,\r\n          // so we'll batch them up and send them every so often.\r\n          self._garbageCollectectedObjects.push(id);\r\n          const objectClass = self._trackedObjectInfo.get(id);\r\n          const object = self._trackedObjects.get(id)?.deref();\r\n\r\n          if (objectClass) {\r\n            if (objectClass === GPUBindGroup) {\r\n              self._bindGroupCount--;\r\n            }\r\n            // If we're here, the object was garbage collected but not explicitly destroyed.\r\n            // Some GPU objects need to be explicitly destroyed, otherwise it's a memory\r\n            // leak. Notify the user of this.\r\n            if (objectClass === GPUBuffer || object === GPUTexture || object === GPUDevice) {\r\n              self._memoryLeakWarning(id);\r\n            }\r\n          }\r\n\r\n          if (self._garbageCollectectedObjects.length > 100) {\r\n            window.postMessage({\"action\": Actions.DeleteObjects, \"idList\": self._garbageCollectectedObjects}, \"*\");\r\n            self._garbageCollectectedObjects.length = 0;\r\n          }\r\n        }\r\n\r\n        self._trackedObjects.delete(id);\r\n        self._trackedObjectInfo.delete(id);\r\n        self._captureTextureRequest.delete(id);\r\n        self._objectMap.delete(id);\r\n      });\r\n\r\n      // Clean out the garbage collected objects every so often.\r\n      const garbageCollectionInterval = 200;\r\n      setInterval(() => {\r\n        if (self._garbageCollectectedObjects.length > 0) {\r\n          window.postMessage({\"action\": Actions.DeleteObjects, \"idList\": self._garbageCollectectedObjects}, \"*\");\r\n          self._garbageCollectectedObjects.length = 0;\r\n        }\r\n      }, garbageCollectionInterval);\r\n\r\n      // Wrap the canvas elements so we can capture when their context is created.\r\n      this._wrapCanvases();\r\n\r\n      // Capture any dynamically created canvases.\r\n      const __createElement = document.createElement;\r\n      document.createElement = function (type) {\r\n        const element = __createElement.call(document, type);\r\n        if (type === \"canvas\") {\r\n          self._wrapCanvas(element);\r\n        }\r\n        return element;\r\n      };\r\n\r\n      // Wrap requestAnimationFrame so it can keep track of framerates and frame captures.\r\n      // This requires that the page uses requestAnimationFrame to drive the rendering loop.\r\n      const __requestAnimationFrame = window.requestAnimationFrame;\r\n      window.requestAnimationFrame = function (cb) {\r\n        function callback() {\r\n          const time = performance.now();\r\n          self._frameStart(time);\r\n          cb(time);\r\n          self._frameEnd();\r\n        }\r\n        __requestAnimationFrame(callback);\r\n      };\r\n\r\n      // Listen for messages from the content-script.\r\n      window.addEventListener('message', (event) => {\r\n        if (event.source !== window) {\r\n          return;\r\n        }\r\n        const message = event.data;\r\n        if (typeof message !== 'object' || message === null) {\r\n          return;\r\n        }\r\n        if (message.action === PanelActions.RequestTexture) {\r\n          const textureId = message.id;\r\n          self._requestTexture(textureId);\r\n        }\r\n        if (message.action === PanelActions.CompileShader) {\r\n          const shaderId = message.id;\r\n          const code = message.code;\r\n          self._compileShader(shaderId, code);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Called before a GPU method is called, allowing the inspector to modify\r\n    // the arguments or the object before the method is called.\r\n    _preMethodCall(object, method, args) {\r\n      const self = this;\r\n\r\n      if (method === \"setPipeline\") {\r\n        // If a shader has been recompiled, that means the pipelines that\r\n        // used that shader were also re-created. Patch in the replacement\r\n        // pipeline so the new version of the shader is used.\r\n        let pipeline = args[0];\r\n        const objectRef = this._objectMap.get(pipeline.__id);\r\n        if (objectRef) {\r\n          if (objectRef.replacement) {\r\n            args[0] = objectRef.replacement;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (method === \"createTexture\") {\r\n        // Add COPY_SRC usage to all textures so we can capture them\r\n        args[0].usage |= GPUTextureUsage.COPY_SRC;\r\n      }\r\n\r\n      if (method === \"createBuffer\") {\r\n        // Add COPY_SRC usage to all buffers so we can capture them\r\n        if (!(args[0].usage & GPUBufferUsage.MAP_READ)) {\r\n          args[0].usage |= GPUBufferUsage.COPY_SRC;\r\n        }\r\n      }\r\n\r\n      if (method === \"createShaderModule\"|| method === \"createRenderPipeline\" || method === \"createComputePipeline\" || method === \"createBindGroup\") {\r\n        if (this._errorChecking) {\r\n          this._skipRecord = true;\r\n          object.pushErrorScope(\"validation\");\r\n          this._skipRecord = false;\r\n        }\r\n      }\r\n\r\n      this._capturedRenderView = null;\r\n      if (method === \"beginRenderPass\") {\r\n        if (this._errorChecking) {\r\n          this._skipRecord = true;\r\n          object.__device.pushErrorScope(\"validation\");\r\n          this._skipRecord = false;\r\n        }\r\n\r\n        const descriptor = args[0];\r\n        const colorAttachments = descriptor.colorAttachments;\r\n        if (colorAttachments) {\r\n          for (let i = 0; i < colorAttachments.length; ++i) {\r\n            const attachment = colorAttachments[i];\r\n            if (attachment.view) {\r\n              // If there's a resolveTarget, get that instead of the regular view, which will\r\n              // have MSAA and can't be read directly.\r\n              const texture = attachment.view.__texture;\r\n              if (texture) {\r\n                if (texture.__isCanvasTexture) {\r\n                  const context = texture.__context;\r\n                  if (context) {\r\n                    if (context.__captureTexture) {\r\n                      if (context.__captureTexture?.width != texture.width ||\r\n                          context.__captureTexture?.height != texture.height ||\r\n                          context.__captureTexture?.format != texture.format) {\r\n                        this._skipRecord = true;\r\n                        context.__captureTexture.destroy();\r\n                        context.__captureTexture = null;\r\n                        context.__canvas.__captureTexture = null;\r\n                        this._skipRecord = false;\r\n                      }\r\n                    }\r\n\r\n                    if (!context.__captureTexture) {\r\n                      const device = context.__device;\r\n                      if (device) {\r\n                        this._skipRecord = true;\r\n                        const captureTexture = device.createTexture({\r\n                          size: [texture.width, texture.height, 1],\r\n                          format: texture.format,\r\n                          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\r\n                        });\r\n                        context.__captureTexture = captureTexture;\r\n                        captureTexture.__id = texture.__id;\r\n                        captureTexture.__view = context.__captureTexture.createView();\r\n                        captureTexture.__view.__texture = captureTexture;\r\n                        captureTexture.__canvasTexture = texture;\r\n                        texture.__captureTexture = captureTexture;\r\n                        texture.__canvas.__captureTexture = captureTexture;\r\n                        this._skipRecord = false;\r\n                      }\r\n                    }\r\n\r\n                    if (context.__captureTexture) {\r\n                      context.__captureTexture.__canvasTexture = texture;\r\n                      attachment.view = context.__captureTexture.__view;\r\n                      this._capturedRenderView = attachment.view;\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Before we finish the command encoder, inject any pending texture captures\r\n      if ((object === this._lastCommandEncoder) && method === \"finish\") {\r\n        if (this._captureTextureRequest.size > 0) {\r\n          this._captureTextureBuffers();\r\n        }\r\n      }\r\n\r\n      // We want to be able to capture canvas textures, so we need to add COPY_SRC to\r\n      // the usage flags of any textures created from canvases.\r\n      if ((object instanceof GPUCanvasContext) && method === \"configure\") {\r\n        const descriptor = args[0];\r\n        if (descriptor.usage) {\r\n          descriptor.usage |= GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\r\n        } else {\r\n          descriptor.usage = GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\r\n        }\r\n        object.__device = descriptor.device;\r\n      }       \r\n\r\n      if (method === \"submit\") {\r\n        this._skipRecord = true;\r\n        object.onSubmittedWorkDone().then(() => {\r\n          if (this._captureTempBuffers.length) {\r\n            self._sendCapturedBuffers();\r\n          }\r\n          if (this._captureTexturedBuffers.length > 0) {\r\n            self._sendCaptureTextureBuffers();\r\n          }\r\n          for (const obj of this._toDestroy) {\r\n            obj.destroy();\r\n          }\r\n          self._toDestroy.length = 0;\r\n        });\r\n        this._skipRecord = false;\r\n      }\r\n    }\r\n\r\n    // Called after a GPU method is called, allowing the inspector to wrap the result.\r\n    _onMethodCall(object, method, args, result, stacktrace) {\r\n      this._frameCommandCount++;\r\n\r\n      if (method === \"beginRenderPass\") {\r\n        result.__commandEncoder = object;\r\n        if (this._capturedRenderView) {\r\n          result.__capturedRenderView = this._capturedRenderView;\r\n        }\r\n      }\r\n\r\n      if (method === \"createShaderModule\" || method === \"createRenderPipeline\" || method === \"createComputePipeline\" || method === \"createBindGroup\") {\r\n        if (this._errorChecking) {\r\n          this._skipRecord = true;\r\n          object.popErrorScope().then((error) => {\r\n            if (error) {\r\n              const id = result?.__id ?? 0;\r\n              window.postMessage({ \"action\": Actions.ValidationError, id, \"message\": error.message, stacktrace }, \"*\");\r\n            }\r\n          });\r\n          this._skipRecord = false;\r\n        }\r\n      }\r\n\r\n      if (method === \"end\") {\r\n        if (this._errorChecking) {\r\n          this._skipRecord = true;\r\n          const device = object.__device;\r\n          if (device) {\r\n            device.popErrorScope().then((error) => {\r\n              if (error) {\r\n                window.postMessage({ \"action\": Actions.ValidationError, \"message\": error.message, stacktrace }, \"*\");\r\n              }\r\n            });\r\n          }\r\n          this._skipRecord = false;\r\n        }\r\n\r\n        // If the captured canvas texture was rendered to, blit it to the real canvas texture\r\n        if (object.__capturedRenderView) {\r\n          const texture = object.__capturedRenderView.__texture;\r\n          if (texture) {\r\n            const commandEncoder = object.__commandEncoder;\r\n            if (commandEncoder) {\r\n              this._skipRecord = true;\r\n              commandEncoder.copyTextureToTexture({ texture },\r\n                { texture: texture.__canvasTexture },\r\n                [texture.width, texture.height, 1]);\r\n              this._skipRecord = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // If __skipRecord is set, don't wrap the result object or record the command.\r\n      // It is set when we're creating utilty objects that aren't from the page.\r\n      if (this._skipRecord) {\r\n        return result;\r\n      }\r\n\r\n      let id = undefined;\r\n      if (method === \"getCurrentTexture\" && result) {\r\n        id = -(object.__canvas?.__id ?? 1);\r\n      } else if (method === \"createView\") {\r\n        if (object.__isCanvasTexture) {\r\n          id = object.__id - 0.5;\r\n        }\r\n      }\r\n\r\n      if (object instanceof GPUDevice && object?.__id === undefined) {\r\n        // We haven't wrapped the object yet, so do it now.\r\n        // Probably the GPUDevice where requestDevice happened\r\n        // before we started recording.\r\n        this._wrapDevice(null, object);\r\n      }\r\n      \r\n      if (result) {\r\n        // Wrap GPU objects\r\n        if (GPUObjectTypes.has(result.constructor)) {\r\n          this._wrapObject(result, id);\r\n        }\r\n\r\n        if (method === \"createShaderModule\" || method === \"createRenderPipeline\") {\r\n          result.__descriptor = args[0];\r\n          result.__device = object;\r\n          this._objectMap.set(result.__id, { id: result.__id, object: new WeakRef(result), replacement: null });\r\n        }\r\n\r\n        if (method === \"createTexture\") {\r\n          this._trackObject(result.__id, result);\r\n        } else if (method === \"createView\" && !id) {\r\n          this._trackObject(result.__id, result);\r\n          result.__texture = object;\r\n        } else if (method === \"createBuffer\") {\r\n          this._trackObject(result.__id, result);\r\n        } else if (method === \"getCurrentTexture\") {\r\n          result.__isCanvasTexture = true;\r\n          result.__context = object;\r\n          this._trackObject(result.__id, result);\r\n          if (object.__canvas) {\r\n            result.__canvas = object.__canvas;\r\n          }\r\n        } else if (method === \"createBindGroup\") {\r\n          this._trackObject(result.__id, result);\r\n        }\r\n      }\r\n\r\n      this._recordCommand(object, method, result, args, stacktrace);\r\n    }\r\n\r\n    // Called when an async GPU method promise resolves, allowing the inspector to wrap the result.\r\n    _onAsyncResolve(object, method, args, id, result, stacktrace) {\r\n      if (method === \"requestAdapter\") {\r\n        const adapter = result;\r\n        if (adapter) {\r\n          this._wrapAdapter(result, id, stacktrace);\r\n        }\r\n      } else if (method === \"requestDevice\") {\r\n        const adapter = object;\r\n        const device = result;\r\n        if (device) {\r\n          this._wrapDevice(adapter, device, id, args, stacktrace);\r\n        }\r\n      } else if (result?.__id) {\r\n        window.postMessage({ action: Actions.ResolveAsyncObject, id: result.__id });\r\n      }\r\n    }\r\n\r\n    _wrapAdapter(adapter, id, stacktrace) {\r\n      this._wrapObject(adapter, id);\r\n      id ??= adapter.__id;\r\n      const self = this;\r\n      adapter.requestAdapterInfo().then((infoObj) => {\r\n        const info = {\r\n          vendor: infoObj.vendor,\r\n          architecture: infoObj.architecture,\r\n          device: infoObj.device,\r\n          description: infoObj.description,\r\n          features: self._gpuToArray(adapter.features),\r\n          limits: self._gpuToObject(adapter.limits),\r\n          isFallbackAdapter: adapter.isFallbackAdapter,\r\n          wgslFeatures: self._gpuToArray(navigator.gpu.wgslLanguageFeatures)\r\n        };\r\n        self._sendAddObjectMessage(id, 0, \"Adapter\", JSON.stringify(info), stacktrace);\r\n      });\r\n    }\r\n\r\n    _wrapDevice(adapter, device, id, args, stacktrace) {\r\n      if (adapter && adapter.__id === undefined) {\r\n        this._wrapAdapter(adapter, undefined, stacktrace);\r\n      }\r\n\r\n      if (device && device.__id === undefined) {\r\n        args ??= [];\r\n        this._wrapObject(device, id);\r\n        const descriptor = args[0] ?? {};\r\n        const deviceId = device.__id;\r\n        const adapterId = adapter?.__id ?? 0;\r\n        descriptor[\"features\"] = this._gpuToArray(device.features);\r\n        descriptor[\"limits\"] = this._gpuToObject(device.limits);\r\n        this._trackObject(deviceId, device);\r\n        this._sendAddObjectMessage(id, adapterId, \"Device\", JSON.stringify(descriptor), stacktrace);\r\n        device.__adapter = adapter; // prevent adapter from being garbage collected\r\n      }\r\n    }\r\n\r\n    clear() {\r\n      this._frameCommands.length = 0;\r\n      this._currentFrame = null;\r\n    }\r\n\r\n    getNextId(object) {\r\n      // We don't need unique id's for some types of objects\r\n      // and they get created so frequenty they make the ID's\r\n      // grow too quickly.\r\n      if (object instanceof GPUCommandEncoder ||\r\n          object instanceof GPUComputePassEncoder ||\r\n          object instanceof GPURenderPassEncoder ||\r\n          object instanceof GPUCommandBuffer) {\r\n        return 0;\r\n      }\r\n      return this._objectID++;\r\n    }\r\n\r\n    _memoryLeakWarning(object) {\r\n      const label = object.label ?? \"\";\r\n      const type = object.constructor.name;\r\n      const id = object.__id;\r\n      const message = `WebGPU ${type} ${id} ${label} was garbage collected without being explicitly destroyed. This is a memory leak.`;\r\n      window.postMessage({\"action\": Actions.MemoryLeakWarning, id, \"message\": message}, \"*\");\r\n    }\r\n\r\n    _isPrimitiveType(obj) {\r\n      return !obj || obj.constructor === String || obj.constructor === Number || obj.constructor === Boolean;\r\n    }\r\n\r\n    _isTypedArray(obj) {\r\n      return obj && (obj instanceof ArrayBuffer || obj.buffer instanceof ArrayBuffer);\r\n    }\r\n\r\n    _isArray(obj) {\r\n      return obj && obj.constructor === Array;\r\n    }\r\n\r\n    _duplicateArray(array, replaceGpuObjects) {\r\n      const newArray = new Array(array.length);\r\n      for (let i = 0, l = array.length; i < l; ++i) {\r\n        const x = array[i];\r\n        if (this._isPrimitiveType(x)) {\r\n          newArray[i] = x;\r\n        } else if (x.__id !== undefined) {\r\n          if (replaceGpuObjects) {\r\n            newArray[i] = { __id: x.__id, __class: x.constructor.name }\r\n          } else {\r\n            newArray[i] = x;\r\n          }\r\n        } else if (this._isTypedArray(x)) {\r\n          newArray[i] = x;\r\n        } else if (this._isArray(x)) {\r\n          newArray[i] = this._duplicateArray(x, replaceGpuObjects);\r\n        } else if (x instanceof Object) {\r\n          newArray[i] = this._duplicateObject(x, replaceGpuObjects);\r\n        } else {\r\n          newArray[i] = x;\r\n        }\r\n      }\r\n      return newArray;\r\n    }\r\n\r\n    _duplicateObject(object, replaceGpuObjects) {\r\n      const obj = {};\r\n      for (const key in object) {\r\n        const x = object[key];\r\n        if (this._isPrimitiveType(x)) {\r\n          obj[key] = x;\r\n        } else if (x.__id !== undefined) {\r\n          if (replaceGpuObjects) {\r\n            obj[key] = { __id: x.__id, __class: x.constructor.name }\r\n          } else {\r\n            obj[key] = x;\r\n          }\r\n        } else if (this._isTypedArray(x)) {\r\n          obj[key] = x;\r\n        } else if (this._isArray(x)) {\r\n          obj[key] = this._duplicateArray(x, replaceGpuObjects);\r\n        } else if (x instanceof Object) {\r\n          obj[key] = this._duplicateObject(x, replaceGpuObjects);\r\n        } else {\r\n          obj[key] = x;\r\n        }\r\n      }\r\n      return obj;\r\n    }\r\n\r\n    _compileShader(shaderId, code) {\r\n      const objectMap = this._objectMap.get(shaderId);\r\n      if (!objectMap) {\r\n        return;\r\n      }\r\n      const shader = objectMap.object?.deref();\r\n      if (!shader) {\r\n        return;\r\n      }\r\n\r\n      const device = shader.__device;\r\n      const descriptor = this._duplicateObject(shader.__descriptor);\r\n      descriptor.code = code;\r\n\r\n      this._skipRecord = true;\r\n      this._errorChecking = false;\r\n      device.pushErrorScope('validation');\r\n      descriptor.__replacement = shaderId;\r\n      const newShaderModule = device.createShaderModule(descriptor);\r\n      device.popErrorScope().then((error) => {\r\n        if (error) {\r\n          const id = shaderId ?? 0;\r\n          window.postMessage({ \"action\": Actions.ValidationError, id, \"message\": error.message }, \"*\");\r\n        }\r\n      });\r\n      this._errorChecking = true;\r\n      this._skipRecord = false;\r\n\r\n      objectMap.replacement = newShaderModule;\r\n\r\n      // Create replacements for any RenderPipeline that uses shaderId\r\n      for (const objectRef of this._objectMap.values()) {\r\n        const object = objectRef.object.deref();\r\n        const isRenderPipeline = object instanceof GPURenderPipeline;\r\n        const isComputePipeline = object instanceof GPUComputePipeline;\r\n        if (isRenderPipeline || isComputePipeline) {\r\n          const descriptor = object.__descriptor;\r\n          let newDescriptor = null;\r\n          \r\n          if (descriptor.vertex?.module === shader) {\r\n            if (!newDescriptor) {\r\n              newDescriptor = this._duplicateObject(descriptor);\r\n            }\r\n            newDescriptor.vertex.module = newShaderModule;\r\n          }\r\n          if (descriptor.fragment?.module === shader) {\r\n            if (!newDescriptor) {\r\n              newDescriptor = this._duplicateObject(descriptor);\r\n            }\r\n            newDescriptor.fragment.module = newShaderModule;\r\n          }\r\n          if (descriptor.compute?.module === shader) {\r\n            if (!newDescriptor) {\r\n              newDescriptor = this._duplicateObject(descriptor);\r\n            }\r\n            newDescriptor.compute.module = newShaderModule;\r\n          }\r\n\r\n          if (newDescriptor !== null) {\r\n            this._skipRecord = true;\r\n            this._errorChecking = false;\r\n            newDescriptor.__replacement = objectRef.id;\r\n            device.pushErrorScope('validation');\r\n            const newPipeline = isRenderPipeline ?\r\n                device.createRenderPipeline(newDescriptor) :\r\n                device.createComputePipeline(newDescriptor);\r\n            device.popErrorScope().then((error) => {\r\n              if (error) {\r\n                const id = objectRef.id ?? 0;\r\n                window.postMessage({ \"action\": Actions.ValidationError, id, \"message\": error.message }, \"*\");\r\n              }\r\n            });\r\n            this._errorChecking = true;\r\n            this._skipRecord = false;\r\n\r\n            objectRef.replacement = newPipeline;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    _requestTexture(textureId) {\r\n      if (textureId < 0) {\r\n        // canvas texture\r\n        const canvasId = -textureId;\r\n        const canvas = this._trackedObjects.get(canvasId).deref();\r\n        if (canvas) {\r\n          if (canvas.__captureTexture) {\r\n            this._captureTextureRequest.set(textureId, canvas.__captureTexture);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n      const object = this._trackedObjects.get(textureId).deref();\r\n      if (!object || !(object instanceof GPUTexture)) {\r\n        return;\r\n      }\r\n      this._captureTextureRequest.set(textureId, object);\r\n    }\r\n\r\n    _updateStatusMessage() {\r\n      let status = \"\";\r\n\r\n      if (this._captureTexturedBuffers.length > 0) {\r\n        status += `Texture: ${this._captureTexturedBuffers.length}`;\r\n      }\r\n\r\n      if (this._mappedTextureBufferCount > 0) {\r\n        status += `Pending Texture Reads: ${this._mappedTextureBufferCount}`;\r\n      }\r\n\r\n      if (this._encodingTextureChunkCount > 0) {\r\n        status += `Pending Texture Encoding: ${this._encodingTextureChunkCount}`;\r\n      }\r\n\r\n      if (this._captureBuffers.length > 0) {\r\n        status += `Buffers: ${this._captureBuffers.length}`;\r\n      }\r\n\r\n      if (this._mappedBufferCount > 0) {\r\n        status += `Pending Buffer Reads: ${this._mappedBufferCount}`;\r\n      }\r\n\r\n      if (this._encodingBufferChunkCount > 0) {\r\n        status += `Pending Buffer Encoding: ${this._encodingBufferChunkCount}`;\r\n      }\r\n\r\n      if (status) {\r\n        status = `Capturing: ${status}`;\r\n      }\r\n\r\n      this._inspectingStatusText.textContent = status;\r\n    }\r\n\r\n    _frameStart(time) {\r\n      if (this._lastFrameTime == 0) {\r\n        this._lastFrameTime = time;\r\n      } else {\r\n        const deltaTime = time - this._lastFrameTime;\r\n        window.postMessage({\"action\": Actions.DeltaTime, deltaTime}, \"*\");\r\n        this._lastFrameTime = time;\r\n      }\r\n\r\n      const captureData = sessionStorage.getItem(webgpuInspectorCaptureFrameKey);\r\n      if (captureData) {\r\n        let data = null;\r\n        try {\r\n          data = JSON.parse(captureData);\r\n        } catch (e) {\r\n          data = null;\r\n        }\r\n        sessionStorage.removeItem(webgpuInspectorCaptureFrameKey);\r\n\r\n        this._captureMaxBufferSize = data.maxBufferSize || maxBufferCaptureSize;\r\n        this._captureRequest = true;\r\n        this._gpuWrapper.recordStacktraces = true;\r\n      }\r\n      this._frameData.length = 0;\r\n      this._frameCommands.length = 0;\r\n      this._frameRenderPassCount = 0;\r\n      this._frameIndex++;\r\n      this._frameCommandCount = 0;\r\n    }\r\n\r\n    _frameEnd() {\r\n      if (this._frameCommands.length) {\r\n        const maxFrameCount = 2000;\r\n        const batches = Math.ceil(this._frameCommands.length / maxFrameCount);\r\n        window.postMessage({\"action\": Actions.CaptureFrameResults, \"frame\": this._frameIndex, \"count\": this._frameCommands.length, \"batches\": batches}, \"*\");\r\n\r\n        for (let i = 0; i < this._frameCommands.length; i += maxFrameCount) {\r\n          const length = Math.min(maxFrameCount, this._frameCommands.length - i);\r\n          const commands = this._frameCommands.slice(i, i + length);\r\n          window.postMessage({\"action\": Actions.CaptureFrameCommands,\r\n              \"frame\": this._frameIndex,\r\n              \"commands\": commands,\r\n              \"index\": i,\r\n              \"count\": length\r\n            }, \"*\");\r\n        }\r\n        this._frameCommands.length = 0;\r\n        this._captureRequest = false;\r\n        this._gpuWrapper.recordStacktraces = false;\r\n      }\r\n\r\n      this._updateStatusMessage();\r\n    }\r\n\r\n    _trackObject(id, object) {\r\n      this._trackedObjects.set(id, new WeakRef(object));\r\n      this._trackedObjectInfo.set(id, object.constructor);\r\n    }\r\n\r\n    _wrapCanvas(c) {\r\n      if (c.__id) {\r\n        return;\r\n      }\r\n      c.__id = this.getNextId(c);\r\n\r\n      this._trackObject(c.__id, c);\r\n\r\n      const self = this;\r\n      const __getContext = c.getContext;\r\n\r\n      c.getContext = function (a1, a2) {\r\n        const ret = __getContext.call(c, a1, a2);\r\n        if (a1 === \"webgpu\") {\r\n          if (ret) {\r\n            self._wrapObject(ret);\r\n            ret.__canvas = c;\r\n          }\r\n        }\r\n        return ret;\r\n      };\r\n    }\r\n\r\n    _wrapCanvases() {\r\n      const canvases = document.getElementsByTagName(\"canvas\");\r\n      for (let i = 0; i < canvases.length; ++i) {\r\n        const c = canvases[i];\r\n        this._wrapCanvas(c);\r\n      }\r\n    }\r\n\r\n    _wrapObject(object, id) {\r\n      // The object has already been wrapped\r\n      if (object.__id) {\r\n        return;\r\n      }\r\n\r\n      object.__id = id ?? this.getNextId(object);\r\n\r\n      // Track garbage collected objects\r\n      this._garbageCollectionRegistry.register(object, object.__id);\r\n\r\n      if (object.label !== undefined) {\r\n        // Capture chaning of the GPUObjectBase label\r\n        const l = object.label;\r\n        object._label = l;\r\n        Object.defineProperty(object, \"label\", {\r\n          enumerable: true,\r\n          configurable: true,\r\n          get() {\r\n            return this._label;\r\n          },\r\n          set(label) {\r\n            if (label !== this._label) {\r\n              this._label = label;\r\n              const id = this.__id;\r\n              window.postMessage({ \"action\": Actions.ObjectSetLabel, id, label }, \"*\");\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      if (object instanceof GPUDevice) {\r\n        // Automatically wrap the device's queue\r\n        if (object.queue.__id === undefined) {\r\n          this._wrapObject(object.queue);\r\n        }\r\n      }\r\n    }\r\n\r\n    _captureTextureBuffers() {\r\n      const self = this;\r\n      this._captureTextureRequest.forEach((texture) => {\r\n        self._captureTexture(self._lastCommandEncoder, texture);\r\n      });\r\n      this._captureTextureRequest.clear();\r\n    }\r\n\r\n    _gpuToArray(gpu) {\r\n      const array = [];\r\n      if (gpu) {\r\n        for (const v of gpu) {\r\n          array.push(v);\r\n        }\r\n      }\r\n      return array;\r\n    }\r\n\r\n    _gpuToObject(gpu) {\r\n      const obj = {};\r\n      if (gpu) {\r\n        for (const v in gpu) {\r\n          obj[v] = gpu[v];\r\n        }\r\n      }\r\n      return obj;\r\n    }\r\n\r\n    _stringifyDescriptor(args) {\r\n      const descriptor = this._duplicateObject(args, true) ?? {};\r\n      //return descriptor;\r\n      const s = JSON.stringify(descriptor);\r\n      return s;\r\n    }\r\n\r\n    _sendAddObjectMessage(id, parent, type, descriptor, stacktrace, pending) {\r\n      window.postMessage({ \"action\": Actions.AddObject, id, parent, type, descriptor, stacktrace, pending }, \"*\");\r\n    }\r\n\r\n    _recordCommand(object, method, result, args, stacktrace) {\r\n      const parent = object?.__id ?? 0;\r\n\r\n      if (method === \"destroy\") {\r\n        const id = object.__id;\r\n        this._trackedObjects.delete(id);\r\n        this._trackedObjectInfo.delete(id);\r\n        this._objectMap.delete(id);\r\n        if (object instanceof GPUBindGroup) {\r\n          this._bindGroupCount--;\r\n        }\r\n        if (id >= 0) {\r\n          this._captureTextureRequest.delete(id);\r\n          window.postMessage({\"action\": Actions.DeleteObject, id}, \"*\");\r\n        }\r\n      } else if (method === \"createShaderModule\") {\r\n        const id = result.__id;\r\n        if (!args[0].__replacement) {\r\n          this._sendAddObjectMessage(id, parent, \"ShaderModule\", this._stringifyDescriptor(args[0]), stacktrace);\r\n        }\r\n      } else if (method === \"createBuffer\") {\r\n        const id = result.__id;\r\n        this._sendAddObjectMessage(id, parent, \"Buffer\", this._stringifyDescriptor(args[0]), stacktrace);\r\n      } else if (method === \"createTexture\") {\r\n        const id = result.__id;\r\n        this._sendAddObjectMessage(id, parent, \"Texture\", this._stringifyDescriptor(args[0]), stacktrace);\r\n        result.__device = object;\r\n      } else if (method === \"getCurrentTexture\") {\r\n        const id = result.__id;\r\n        if (result) {\r\n          const info = {\r\n            size: [result.width, result.height, result.depthOrArrayLayers],\r\n            mipLevelCount: result.mipLevelCount,\r\n            sampleCount: result.sampleCount,\r\n            dimension: result.dimension,\r\n            format: result.format,\r\n            usage: result.usage\r\n          };\r\n          const infoStr = JSON.stringify(info);\r\n          this._sendAddObjectMessage(id, parent, \"Texture\", infoStr, stacktrace);\r\n        }\r\n      } else if (method === \"createView\") {\r\n        const id = result.__id;\r\n        result.__texture = object;\r\n        this._sendAddObjectMessage(id, parent, \"TextureView\", this._stringifyDescriptor(args[0]), stacktrace);\r\n      } else if (method === \"createSampler\") {\r\n        const id = result.__id;\r\n        this._sendAddObjectMessage(id, parent, \"Sampler\", this._stringifyDescriptor(args[0]), stacktrace);\r\n      } else if (method === \"createBindGroup\") {\r\n        this._bindGroupCount++;\r\n        const id = result.__id;\r\n        result.__descriptor = args[0];\r\n        this._sendAddObjectMessage(id, parent, \"BindGroup\", this._stringifyDescriptor(args[0]), stacktrace);\r\n      } else if (method === \"createBindGroupLayout\") {\r\n        const id = result.__id;\r\n        result.__descriptor = args[0];\r\n        this._sendAddObjectMessage(id, parent, \"BindGroupLayout\", this._stringifyDescriptor(args[0]), stacktrace);\r\n      } else if (method === \"createPipelineLayout\") {\r\n        const id = result.__id;\r\n        this._sendAddObjectMessage(id, parent, \"PipelineLayout\", this._stringifyDescriptor(args[0]), stacktrace);\r\n      } else if (method === \"createRenderPipeline\") {\r\n        const id = result.__id;\r\n        if (!args[0].__replacement) {\r\n          this._sendAddObjectMessage(id, parent, \"RenderPipeline\", this._stringifyDescriptor(args[0]), stacktrace);\r\n          // There are cases when the shader modules used by the render pipeline will be garbage collected, and we won't be able to inspect them after that.\r\n          // Hang on to the shader modules used in the descriptor by attaching them to the pipeline.\r\n          if (args[0].vertex?.module) {\r\n            result.__vertexModule = args[0].vertex?.module;\r\n          }\r\n          if (args[0].fragment?.module) {\r\n            result.__fragmentModule = args[0].fragment?.module;\r\n          }\r\n        }\r\n      } else if (method === \"createComputePipeline\") {\r\n        const id = result.__id;\r\n        if (!args[0].__replacement) {\r\n          this._sendAddObjectMessage(id, parent, \"ComputePipeline\", this._stringifyDescriptor(args[0]), stacktrace);\r\n          if (args[0].compute?.module) {\r\n            result.__computeModule = args[0].compute?.module;\r\n          }\r\n        }\r\n      } else if (method === \"createCommandEncoder\") {\r\n        // We'll need the CommandEncoder's device for capturing textures\r\n        result.__device = object;\r\n        this._lastCommandEncoder = result;\r\n      } else if (method === \"finish\") {\r\n        if (object == this._lastCommandEncoder) {\r\n          this._lastCommandEncoder = null;\r\n        }\r\n      } else if (method === \"beginRenderPass\") {\r\n        this._frameRenderPassCount++;\r\n      }\r\n\r\n      if (this._captureRequest) {\r\n        this._captureCommand(object, method, args, stacktrace);\r\n      }\r\n    }\r\n\r\n    _captureCommand(object, method, args, stacktrace) {\r\n      const commandId = this._frameCommands.length;\r\n\r\n      const a = args;\r\n      if (a.length === 1 && a[0] === undefined) {\r\n        a.length = 0;\r\n      }\r\n\r\n      let newArgs = null;\r\n      if (method === \"setBindGroup\") {\r\n        newArgs = [];\r\n        const binding = a[0];\r\n        const bindGroup = a[1];\r\n        newArgs.push(binding);\r\n        newArgs.push(bindGroup);\r\n        // handle dynamic offsets data, converting buffer views to Uint32Array\r\n        if (a.length > 2) {\r\n          const array = a[2];\r\n          if (array.length > 0) {\r\n            if (array instanceof Uint32Array) {\r\n              const offset = a[3];\r\n              const size = a[4];\r\n              if (size > 0) {\r\n                const subArray = new Uint32Array(array.buffer, offset * 4, size);\r\n                newArgs.push(subArray);\r\n              }\r\n            } else {\r\n              newArgs.push(array);\r\n            }\r\n          }\r\n        }\r\n\r\n        const dynamicOffsets = (newArgs.length > 2) ? newArgs[2] : null;\r\n        let dynamicOffsetIndex = 0;\r\n        const bindGroupDesc = bindGroup.__descriptor;\r\n        const bindGroupLayoutDesc = bindGroupDesc.layout?.__descriptor;\r\n        if (bindGroupDesc && bindGroupLayoutDesc) {\r\n          for (const entryIndex in bindGroupDesc.entries) {\r\n            const entry = bindGroupDesc.entries[entryIndex];\r\n            const layoutEntry = bindGroupLayoutDesc.entries[entryIndex];\r\n            const buffer = entry?.resource?.buffer;\r\n            const usesDynamicOffset = layoutEntry?.buffer?.hasDynamicOffset ?? false;\r\n            if (buffer && layoutEntry) {\r\n              let offset = entry.resource.offset ?? 0;\r\n              const size = entry.resource.size ?? buffer.size;\r\n\r\n              if (size < this._captureMaxBufferSize) {\r\n                if (usesDynamicOffset) {\r\n                  offset = dynamicOffsets[dynamicOffsetIndex++];\r\n                }\r\n\r\n                this._captureBuffers.push({ commandId, entryIndex, buffer, offset, size });\r\n                this._updateStatusMessage();\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else if (method === \"writeBuffer\") {\r\n        newArgs = [];\r\n        const buffer = a[0];\r\n        const bufferOffset = a[1];\r\n        newArgs.push(buffer);\r\n        newArgs.push(bufferOffset);\r\n        let data = a[2];\r\n        if (a.length > 3) {\r\n          const offset = a[3] ?? 0;\r\n          const size = a[4];\r\n          const buffer = data instanceof ArrayBuffer ? data : data.buffer;\r\n          if (!buffer) { \r\n            // It's a []<number>\r\n          } else if (size > 0) {\r\n            data = new Uint8Array(buffer, offset, size);\r\n          } else if (offset > 0) {\r\n            data = new Uint8Array(buffer, offset);\r\n          }\r\n        }\r\n        // We can't push the actual data to the inspector server, it would be too much data.\r\n        // Instead, we push a description of the data. If we actually want the data, we should\r\n        // push it seperately in chunks as an ID'd data block, and then reference that ID here.\r\n        newArgs.push(data);\r\n      } else {\r\n        newArgs = a;\r\n      }\r\n\r\n      newArgs = this._processCommandArgs(newArgs);\r\n\r\n      this._frameCommands.push({\r\n        \"class\": object.constructor.name,\r\n        \"id\": object.__id,\r\n        commandId,\r\n        method,\r\n        args: newArgs,\r\n        stacktrace\r\n      });\r\n\r\n      if (method === \"beginRenderPass\") {\r\n        if (args[0]?.colorAttachments?.length > 0) {\r\n          for (const attachment of args[0].colorAttachments) {\r\n            const captureTextureView = attachment.resolveTarget ?? attachment.view;\r\n            this._captureTextureViews.push(captureTextureView);\r\n          }\r\n        }\r\n        this._captureCommandEncoder = object;\r\n      } else if (method === \"beginComputePass\") {\r\n        this._captureCommandEncoder = object;\r\n      } else if (method === \"end\") {\r\n        if (this._captureBuffers.length > 0) {\r\n          this._recordCaptureBuffers(this._captureCommandEncoder);\r\n          this._updateStatusMessage();\r\n        }\r\n        if (this._captureTextureViews.length > 0) {\r\n          for (const captureTextureView of this._captureTextureViews) {\r\n            const texture = captureTextureView.__texture;\r\n            if (texture) {\r\n              this._captureTexture(this._captureCommandEncoder, texture, this._frameRenderPassCount - 1);\r\n            }\r\n          }\r\n          this._captureTextureViews.length = 0;\r\n        }\r\n        this._captureCommandEncoder = null;\r\n      }\r\n    }\r\n\r\n    _sendCaptureTextureBuffers() {\r\n      const textures = [];\r\n      for (const textureBuffer of this._captureTexturedBuffers) {\r\n        textures.push(textureBuffer.id);\r\n      }\r\n\r\n      let totalChunks = 0;\r\n      for (const textureBuffer of this._captureTexturedBuffers) {\r\n        const size = textureBuffer.tempBuffer.size;\r\n        const numChunks = Math.ceil(size / maxDataChunkSize);\r\n        totalChunks += numChunks;\r\n      }\r\n\r\n      window.postMessage({\r\n        \"action\": Actions.CaptureTextureFrames, \r\n        \"chunkCount\": totalChunks,\r\n        \"count\": this._captureTexturedBuffers.length,\r\n        textures }, \"*\");\r\n\r\n      for (const textureBuffer of this._captureTexturedBuffers) {\r\n        const { id, tempBuffer, passId } = textureBuffer;\r\n\r\n        this._mappedTextureBufferCount++;\r\n        const self = this;\r\n        tempBuffer.mapAsync(GPUMapMode.READ).then(() => {\r\n          self._mappedTextureBufferCount--;\r\n          self._updateStatusMessage();\r\n          const range = tempBuffer.getMappedRange();\r\n          const data = new Uint8Array(range);\r\n          self._sendTextureData(id, passId, data);\r\n          tempBuffer.destroy();\r\n        });\r\n      }\r\n      this._captureTexturedBuffers.length = 0;\r\n      this._updateStatusMessage();\r\n    }\r\n\r\n    _sendTextureData(id, passId, data) {\r\n      const size = data.length;\r\n      const numChunks = Math.ceil(size / maxDataChunkSize);\r\n\r\n      const self = this;\r\n      for (let i = 0; i < numChunks; ++i) {\r\n        const offset = i * maxDataChunkSize;\r\n        const chunkSize = Math.min(maxDataChunkSize, size - offset);\r\n        const chunk = data.slice(offset, offset + chunkSize);\r\n\r\n        this._encodingTextureChunkCount++;\r\n        this._updateStatusMessage();\r\n        encodeDataUrl(chunk).then((chunkData) => {\r\n          window.postMessage({\r\n            \"action\": Actions.CaptureTextureData,\r\n            id,\r\n            passId,\r\n            offset,\r\n            size,\r\n            index: i,\r\n            count: numChunks,\r\n            chunk: chunkData\r\n          }, \"*\");\r\n          self._encodingTextureChunkCount--;\r\n          self._updateStatusMessage();\r\n        });\r\n      }\r\n    }\r\n\r\n    _getTextureUtils(device) {\r\n      if (!device) {\r\n        return null;\r\n      }\r\n      if (!device.__textureUtils) {\r\n        device.__textureUtils = new TextureUtils(device);\r\n      }\r\n      return device.__textureUtils;\r\n    }\r\n\r\n    _sendBufferData(commandId, entryIndex, data) {\r\n      const size = data.length;\r\n      const numChunks = Math.ceil(size / maxDataChunkSize);\r\n      const self = this;\r\n\r\n      for (let i = 0; i < numChunks; ++i) {\r\n        const offset = i * maxDataChunkSize;\r\n        const chunkSize = Math.min(maxDataChunkSize, size - offset);\r\n        const chunk = data.slice(offset, offset + chunkSize);\r\n\r\n        this._encodingBufferChunkCount++;\r\n        this._updateStatusMessage();\r\n        encodeDataUrl(chunk).then((chunkData) => {\r\n          window.postMessage({\r\n            \"action\": Actions.CaptureBufferData,\r\n            commandId,\r\n            entryIndex,\r\n            offset,\r\n            size,\r\n            index: i,\r\n            count: numChunks,\r\n            chunk: chunkData\r\n          }, \"*\");\r\n          self._encodingBufferChunkCount--;\r\n          self._updateStatusMessage();\r\n        });\r\n      }\r\n    }\r\n\r\n    _sendCapturedBuffers() {\r\n      const buffers = this._captureTempBuffers;\r\n      if (buffers.length > 0) {\r\n        let totalChunks = 0;\r\n        for (const bufferInfo of buffers) {\r\n          const size = bufferInfo.tempBuffer.size;\r\n          const numChunks = Math.ceil(size / maxDataChunkSize);\r\n          totalChunks += numChunks;\r\n        }\r\n        window.postMessage({\r\n          \"action\": Actions.CaptureBuffers,\r\n          \"count\": buffers.length,\r\n          \"chunkCount\": totalChunks }, \"*\");\r\n      }\r\n\r\n      for (const bufferInfo of buffers) {\r\n        const tempBuffer = bufferInfo.tempBuffer;\r\n        const commandId = bufferInfo.commandId;\r\n        const entryIndex = bufferInfo.entryIndex;\r\n        const self = this;\r\n        this._mappedBufferCount++;\r\n        this._updateStatusMessage();\r\n        tempBuffer.mapAsync(GPUMapMode.READ).then(() => {\r\n          self._mappedBufferCount--;\r\n          self._updateStatusMessage();\r\n          const range = tempBuffer.getMappedRange();\r\n          const data = new Uint8Array(range);\r\n          self._sendBufferData(commandId, entryIndex, data);\r\n          tempBuffer.destroy();\r\n        });\r\n      }\r\n      this._captureTempBuffers.length = 0;\r\n    }\r\n\r\n    _recordCaptureBuffers(commandEncoder) {\r\n      const buffers = this._captureBuffers;\r\n      const device = commandEncoder?.__device;\r\n      if (!device) {\r\n        buffers.length = 0;\r\n        return;\r\n      }\r\n\r\n      for (const bufferInfo of buffers) {\r\n        const { commandId, entryIndex, buffer, offset, size } = bufferInfo;\r\n\r\n        let tempBuffer = null;\r\n        this._skipRecord = true;\r\n        try {\r\n          tempBuffer = device.createBuffer({\r\n            size,\r\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\r\n            label: `BUFFER CAPTURE TEMP [${commandId},${entryIndex}]`\r\n          });\r\n\r\n          commandEncoder.copyBufferToBuffer(buffer, offset, tempBuffer, 0, size);\r\n\r\n          this._captureTempBuffers.push({ commandId, entryIndex, tempBuffer });\r\n          \r\n        } catch (e) {\r\n          console.log(e);\r\n        }\r\n        this._skipRecord = false;\r\n      }\r\n      buffers.length = 0;\r\n    }\r\n\r\n    _captureTexture(commandEncoder, texture, passId) {\r\n      const device = commandEncoder?.__device;\r\n      // can't capture canvas texture\r\n      if (!device) {\r\n        return;\r\n      }\r\n\r\n      passId ??= -1;\r\n\r\n      const id = texture.__id;\r\n      let format = texture.format;\r\n      let formatInfo = format ? TextureFormatInfo[format] : undefined;\r\n      if (!formatInfo) { // GPUExternalTexture?\r\n        return;\r\n      }\r\n\r\n      // depth24plus texture's can't be copied to a buffer,\r\n      // https://github.com/gpuweb/gpuweb/issues/652.\r\n      if (format === \"depth24plus\" || format === \"depth24plus-stencil8\") {\r\n        this._skipRecord = true;\r\n        try {\r\n          const textureUtils = this._getTextureUtils(texture.__device);\r\n          texture = textureUtils.copyDepthTexture(texture, format === \"depth24plus-stencil8\" ? \"depth32float\" : \"depth32float-stencil8\");\r\n        } catch (e) {\r\n          this._skipRecord = false;\r\n          console.log(e);\r\n          return;\r\n        }\r\n        this._skipRecord = false;\r\n        format = texture.format;\r\n        formatInfo = format ? TextureFormatInfo[format] : undefined;\r\n        texture.__id = id;\r\n        this._toDestroy.push(texture); // Destroy the temp texture at the end of the frame\r\n      }\r\n\r\n      const width = texture.width;\r\n      const height = texture.height || 1;\r\n      const depthOrArrayLayers = texture.depthOrArrayLayers || 1;\r\n      const texelByteSize = formatInfo.bytesPerBlock;\r\n      const bytesPerRow = (width * texelByteSize + 255) & ~0xff;\r\n      const rowsPerImage = height;\r\n      const bufferSize = bytesPerRow * rowsPerImage * depthOrArrayLayers;\r\n      if (!bufferSize) {\r\n        return;\r\n      }\r\n      const copySize = { width, height, depthOrArrayLayers };\r\n\r\n      let tempBuffer = null;\r\n      try {\r\n        this._skipRecord = true;\r\n        tempBuffer = device.createBuffer({\r\n          size: bufferSize,\r\n          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\r\n        });\r\n\r\n        const aspect = format === 'depth24plus-stencil8' || format === 'depth32float-stencil8' ? 'depth-only' : 'all';\r\n\r\n        commandEncoder.copyTextureToBuffer(\r\n          { texture, aspect },\r\n          { buffer: tempBuffer, bytesPerRow, rowsPerImage: height },\r\n          copySize\r\n        );\r\n\r\n      } catch (e) {\r\n        console.log(e);\r\n      }\r\n      this._skipRecord = false;\r\n\r\n      if (tempBuffer) {\r\n        this._captureTexturedBuffers.push({ id, tempBuffer, width, height, depthOrArrayLayers, format, passId });\r\n        this._updateStatusMessage();\r\n      }\r\n    }\r\n\r\n    _addCommandData(data) {\r\n      if (this._captureRequest) {\r\n        const id = this._frameData.length;\r\n        this._frameData.push(data);\r\n        return id;\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    // Convert any objects to a string representation that can be sent to the inspector server.\r\n    _processCommandArgs(object) {\r\n      if (!object || object.constructor === Number || object.constructor === String || object.constructor === Boolean) {\r\n        return object;\r\n      }\r\n      if (object.__id !== undefined) {\r\n        return {\"__id\": object.__id, \"__class\": object.constructor.name };\r\n      }\r\n      if (object instanceof ImageBitmap ||\r\n        object instanceof ImageData ||\r\n        object instanceof HTMLImageElement ||\r\n        object instanceof HTMLCanvasElement ||\r\n        object instanceof HTMLVideoElement ||\r\n        object instanceof OffscreenCanvas ||\r\n        object instanceof VideoFrame) {\r\n        return `@-1 ${object.constructor.name} ${object.width} ${object.height}`;\r\n      }\r\n      if (object instanceof Array || object.buffer !== undefined) {\r\n        const maxMessageArrayLength = 100;\r\n        if (object.length > maxMessageArrayLength) {\r\n          const id = this._addCommandData(object);\r\n          return `@${id} ${object.constructor.name} ${object.byteLength}`;\r\n        }\r\n        const newArray = [];\r\n        for (const i in object) {\r\n          newArray[i] = this._processCommandArgs(object[i]);\r\n        }\r\n        return newArray;\r\n      }\r\n      if (object instanceof ArrayBuffer) {\r\n        const id = this._addCommandData(object);\r\n        return `@${id} ${object.constructor.name} ${object.byteLength}`;\r\n      }\r\n      if (object instanceof Object) {\r\n        const newObject = {};\r\n        for (const key in object) {\r\n          newObject[key] = this._processCommandArgs(object[key]);\r\n        }\r\n        return newObject;\r\n      }\r\n      return object;\r\n    }\r\n  }\r\n\r\n  WebGPUInspector._asyncMethods = [\r\n    \"requestAdapter\",\r\n    \"requestDevice\",\r\n    \"createComputePipelineAsync\",\r\n    \"createRenderPipelineAsync\",\r\n  ];\r\n\r\n  WebGPUInspector._skipMethods = [\r\n    \"toString\",\r\n    \"entries\",\r\n    \"getContext\",\r\n    \"forEach\",\r\n    \"has\",\r\n    \"keys\",\r\n    \"values\",\r\n    \"getPreferredFormat\",\r\n    \"pushErrorScope\",\r\n    \"popErrorScope\",\r\n  ];\r\n\r\n  new WebGPUInspector();\r\n})();\r\n"],"names":["async","encodeDataUrl","bytes","type","Promise","resolve","reject","reader","Object","assign","FileReader","onload","result","onerror","error","readAsDataURL","File","Signal","constructor","name","this","_lastSlotId","slots","Map","enabled","_disableSignals","disabled","disable","enable","force","disconnect","object","callback","instance","i","p","getSignals","out","push","hasListeners","size","emit","k","s","o","apply","arguments","addListener","isListening","set","slot","slotInfo","clear","Number","handle","has","delete","found","slotHandle","getStacktrace","Error","captureStackTrace","stacktrace","stack","split","map","line","slice","filter","includes","join","GPUObjectTypes","Set","GPUAdapter","GPUDevice","GPUBuffer","GPUTexture","GPUTextureView","GPUSampler","GPUBindGroupLayout","GPUBindGroup","GPUPipelineLayout","GPUShaderModule","GPUComputePipeline","GPURenderPipeline","GPUCommandBuffer","GPUCommandEncoder","GPUComputePassEncoder","GPURenderPassEncoder","GPURenderBundle","GPUQueue","GPUQuerySet","GPUCanvasContext","GPUCreateMethods","GPUObjectWrapper","idGenerator","_idGenerator","onPreCall","onPostCall","onPromise","onPromiseResolve","recordStacktraces","_wrapGPUTypes","GPU","prototype","requestAdapter","_wrapMethod","getPreferredFormat","requestDevice","destroy","createBuffer","createTexture","createSampler","importExternalTexture","createBindGroupLayout","createPipelineLayout","createBindGroup","createShaderModule","createComputePipeline","createRenderPipeline","createComputePipelineAsync","createRenderPipelineAsync","createCommandEncoder","createRenderBundleEncoder","createQuerySet","mapAsync","getMappedRange","unmap","createView","getCompilationInfo","getBindGroupLayout","beginRenderPass","beginComputePass","copyBufferToBuffer","copyBufferToTexture","copyTextureToBuffer","copyTextureToTexture","clearBuffer","resolveQuerySet","finish","pushDebugGroup","popDebugGroup","insertDebugMarker","setPipeline","dispatchWorkgroups","dispatchWorkgroupsIndirect","end","setBindGroup","setViewport","setScissorRect","setBlendConstant","setStencilReference","beginOcclusionQuery","endOcclusionQuery","executeBundles","setIndexBuffer","setVertexBuffer","draw","drawIndexed","drawIndirect","drawIndexedIndirect","submit","writeBuffer","writeTexture","copyExternalImageToTexture","configure","unconfigure","getCurrentTexture","method","origMethod","self","args","call","isCreate","undefined","id","getNextId","promise","wrappedPromise","then","TextureFormatInfo","r8unorm","bytesPerBlock","blockWidth","blockHeight","isCompressed","r8snorm","r8uint","r8sint","rg8unorm","rg8snorm","rg8uint","rg8sint","rgba8unorm","rgba8snorm","rgba8uint","rgba8sint","bgra8unorm","r16uint","r16sint","r16float","rg16uint","rg16sint","rg16float","rgba16uint","rgba16sint","rgba16float","r32uint","r32sint","r32float","rg32uint","rg32sint","rg32float","rgba32uint","rgba32sint","rgba32float","rgb10a2uint","rgb10a2unorm","rg11b10ufloat","stencil8","isDepthStencil","hasDepth","hasStencil","depth16unorm","depth24plus","depthOnlyFormat","depth32float","stencilOnlyFormat","rgb9e5ufloat","TextureUtils","device","blitShaderModule","code","blitShader","blitDepthShaderModule","blitDepthShader","blitPipelines","blitDepthPipelines","bindGroupLayouts","pipelineLayouts","pointSampler","magFilter","minFilter","displayUniformBuffer","usage","GPUBufferUsage","UNIFORM","COPY_DST","displayBingGroupLayout","entries","binding","visibility","GPUShaderStage","FRAGMENT","buffer","displayBindGroup","layout","resource","copyDepthTexture","src","format","width","height","GPUTextureUsage","RENDER_TARGET","COPY_SRC","dst","pipeline","vertex","module","entryPoint","fragment","targets","depthStencil","depthWriteEnabled","depthCompare","primitive","topology","srcView","aspect","bindGroupLayout","bindGroup","commandEncoder","passDesc","colorAttachments","depthStencilAttachment","view","depthLoadOp","depthStoreOp","depthClearValue","depthReadOnly","passEncoder","queue","blitTexture","dstFormat","display","sampleType","sampler","texture","pipelineLayout","get","pipelineKey","loadOp","storeOp","Float32Array","exposure","Actions","CaptureBufferData","CaptureBuffers","DeleteObjects","ValidationError","MemoryLeakWarning","DeltaTime","CaptureFrameResults","CaptureFrameCommands","ObjectSetLabel","AddObject","ResolveAsyncObject","DeleteObject","CaptureTextureFrames","CaptureTextureData","Recording","values","PanelActions","webgpuInspectorCaptureFrameKey","maxDataChunkSize","WebGPUInspector","_frameCommands","_frameData","_frameRenderPassCount","_captureTextureViews","_lastCommandEncoder","_captureCommandEncoder","_captureTexturedBuffers","_currentFrame","_frameIndex","_initalized","_objectID","_lastFrameTime","_frameCommandCount","_captureRequest","_skipRecord","_errorChecking","_trackedObjects","_trackedObjectInfo","_bindGroupCount","_captureTextureRequest","_toDestroy","_objectMap","_captureBuffers","_captureTempBuffers","_mappedTextureBufferCount","_encodingTextureChunkCount","_mappedBufferCount","_encodingBufferChunkCount","window","navigator","gpu","statusContainer","document","createElement","style","body","insertBefore","firstChild","_inspectingStatus","title","appendChild","_inspectingStatusText","_gpuWrapper","_onAsyncResolve","_preMethodCall","_onMethodCall","_garbageCollectectedObjects","_garbageCollectionRegistry","FinalizationRegistry","objectClass","deref","_memoryLeakWarning","length","postMessage","action","idList","setInterval","_wrapCanvases","__createElement","element","_wrapCanvas","__requestAnimationFrame","requestAnimationFrame","cb","time","performance","now","_frameStart","_frameEnd","addEventListener","event","source","message","data","textureId","_requestTexture","shaderId","_compileShader","objectRef","__id","replacement","MAP_READ","pushErrorScope","_capturedRenderView","__device","attachment","__texture","__isCanvasTexture","context","__context","__captureTexture","__canvas","captureTexture","RENDER_ATTACHMENT","__view","__canvasTexture","_captureTextureBuffers","descriptor","onSubmittedWorkDone","_sendCapturedBuffers","_sendCaptureTextureBuffers","obj","__commandEncoder","__capturedRenderView","popErrorScope","_wrapDevice","_wrapObject","__descriptor","WeakRef","_trackObject","_recordCommand","_wrapAdapter","adapter","requestAdapterInfo","infoObj","info","vendor","architecture","description","features","_gpuToArray","limits","_gpuToObject","isFallbackAdapter","wgslFeatures","wgslLanguageFeatures","_sendAddObjectMessage","JSON","stringify","deviceId","adapterId","__adapter","label","_isPrimitiveType","String","Boolean","_isTypedArray","ArrayBuffer","_isArray","Array","_duplicateArray","array","replaceGpuObjects","newArray","l","x","__class","_duplicateObject","key","objectMap","shader","__replacement","newShaderModule","isRenderPipeline","isComputePipeline","newDescriptor","compute","newPipeline","canvasId","canvas","_updateStatusMessage","status","textContent","deltaTime","captureData","sessionStorage","getItem","parse","e","removeItem","_captureMaxBufferSize","maxBufferSize","maxFrameCount","batches","Math","ceil","frame","count","min","commands","index","c","__getContext","getContext","a1","a2","ret","canvases","getElementsByTagName","register","_label","defineProperty","enumerable","configurable","forEach","_captureTexture","v","_stringifyDescriptor","parent","pending","depthOrArrayLayers","mipLevelCount","sampleCount","dimension","infoStr","__vertexModule","__fragmentModule","__computeModule","_captureCommand","commandId","a","newArgs","Uint32Array","offset","subArray","dynamicOffsets","dynamicOffsetIndex","bindGroupDesc","bindGroupLayoutDesc","entryIndex","entry","layoutEntry","usesDynamicOffset","hasDynamicOffset","bufferOffset","Uint8Array","_processCommandArgs","class","captureTextureView","resolveTarget","_recordCaptureBuffers","textures","textureBuffer","totalChunks","tempBuffer","chunkCount","passId","GPUMapMode","READ","range","_sendTextureData","numChunks","chunkSize","chunk","chunkData","_getTextureUtils","__textureUtils","_sendBufferData","buffers","bufferInfo","console","log","formatInfo","bytesPerRow","bufferSize","copySize","rowsPerImage","_addCommandData","ImageBitmap","ImageData","HTMLImageElement","HTMLCanvasElement","HTMLVideoElement","OffscreenCanvas","VideoFrame","maxMessageArrayLength","byteLength","newObject","_asyncMethods","_skipMethods"],"mappings":"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"}